/**
 **************************************************************************
 * \file VS_Direct3DRender.cpp
 * (c) 2002-2004 Visicron Inc.  http://www.visicron.net/
 * \brief D3D Render classes Implementation
 *
 * \b Project Client
 * \author Anufriev Sergey
 * \date 20.05.2010
 **************************************************************************/

/****************************************************************************
 * Includes
 ****************************************************************************/
#include <windows.h>
#include <Ole2.h>
#include <initguid.h>
#include "VSRender.h"
#include "VS_Dmodule.h"
#include "VS_ApplicationInfo.h"
#include "../std/VS_ProfileTools.h"
#include "std-generic/cpplib/VS_Container.h"
#include <d3d9types.h>
#include <Ksmedia.h>
#include <Setupapi.h>
#include <devguid.h>

HRESULT VSGetDXVersion(DWORD *DXVersionMajor, DWORD *DXVersionMinor);
/**
****************************************************************************
 * \brief Get Direct3D information and form sring
 *
 * \param prop			- sring to fill
 *
 * \date    14-01-2011
 ******************************************************************************/
int VSGetDirect3DInfo(VS_SimpleStr &prop, HWND hwnd)
{
	int ret = 0;
	char str[16384] = {0};

	DWORD DXMajor, DXMinor;
	if (S_OK == VSGetDXVersion(&DXMajor, &DXMinor)) {
		sprintf(str, "Version DirectX:      %ld.%ld\n\n", DXMajor, DXMinor);
	} else {
		sprintf(str, "Version DirectX:      unknown\n\n");
	}
	prop += str;

	/// test Direct3d10
	str[0] = 0;
	bool bDirect3D10 = false;
	if (g_hD3D10 && g_hDXGI) {
		VS_Direct3D10Render *vrender = new VS_Direct3D10Render(NULL, hwnd);
		VS_D3DCAPS caps;
		vrender->GetDirect3DCaps(&caps);
		if (!vrender->m_bUseD3D) {
			sprintf(str, "d3d10.dll = %p, dxgi.dll = %p\n", g_hD3D10, g_hDXGI);
			strcat(str, caps.Error);
			strcat(str, "Direct3D10 NOT USED\n\n");
		} else {
			str[0] = 0;
			char szDriver[MAX_DEVICE_IDENTIFIER_STRING*32] = {0};
			char szDesc[MAX_DEVICE_IDENTIFIER_STRING*32] = {0};
			vrender->FillDeviceInfo(szDriver, szDesc);
			if (*szDriver) sprintf(str, "Driver:       %s ", szDriver);
			if (*szDesc) strcat(str, szDesc);
			strcat(str, "\nDirect3D10 INIT OK");
			bDirect3D10 = true;
			ret = 1;
		}
		delete vrender;
	} else {
		sprintf(str, "d3d10.dll = %p, dxgi.dll = %p\n", g_hD3D10, g_hDXGI);
		strcat(str, "Direct3D10 NOT USED\n\n");
	}
	prop += str;

	/// test Direct3d9 if need
	str[0] = 0;
	if (!bDirect3D10) {
		if (g_hD3D9 && g_pD3DXCompileShader && g_pDirect3DCreate9Ex) {

			VS_Direct3DRender *vrender = new VS_Direct3DRender(NULL, hwnd);

			VS_D3DCAPS caps;
			vrender->GetDirect3DCaps(&caps);

			if (!vrender->m_bUseD3D) {
				sprintf(str, "d3d9.dll = %p, D3DXCompileShader = %p, Direct3DCreate9Ex = %p\n", g_hD3D9, g_pD3DXCompileShader, g_pDirect3DCreate9Ex);
				strcat(str, caps.Error);
				strcat(str, "Direct3D9 NOT USED");
				ret = 0;
			} else  {
				char	szDriver[MAX_DEVICE_IDENTIFIER_STRING] = {0};
				char	szDesc[MAX_DEVICE_IDENTIFIER_STRING] = {0};
				if (vrender->FillDeviceInfo(szDriver, szDesc)) {
					if (*szDriver) {
						sprintf(str, "Driver:       %s ", szDriver);
						if (*szDesc)
							strcat(str, szDesc);
						prop+=str;
					}
				}

				sprintf(str, "\nResolution:   %dx%d, %d bit \n", caps.uWidth, caps.uHeight, caps.uDepth);
				prop+=str;

				sprintf(str, "Video Memory: available - %u MB\n", caps.uMemAvailable / 1024 / 1024);
				prop+=str;

				sprintf(str, "Capabilities: |  VS  | TR | HV | GPU |\n");
				prop += str;
				sprintf(str,"              | %d.%d  | %d  | %d  |  %d  |\n",
						caps.uShaderVerMajor, caps.uShaderVerMinor,
						caps.uTypeShaderResampler,
						caps.uVertexProcessing,
						caps.uGPUPriotity);
				strcat(str, "\nDirect3D9 INIT OK");
				ret = 1;
			}

			delete vrender;
		} else {
			sprintf(str, "d3d9.dll = %p, D3DXCompileShader = %p, Direct3DCreate9Ex = %p\n", g_hD3D9, g_pD3DXCompileShader, g_pDirect3DCreate9Ex);
			strcat(str, "Direct3D9 NOT USED");
		}
	}
	prop += str;

	return ret;
}

VS_Direct3DRender::VS_Direct3DRender(CVSInterface* pParentInterface, HWND hwnd) : CVideoRenderBase(pParentInterface)
{
	m_cError[0] = 0;
	m_repairTime = 0;
	m_bCanFS = 1;
	m_IsValid = false;
	m_bUseD3D = TestD3DCaps(hwnd);
	m_TypeRender = VR_DIRECT_3D9;
}

VS_Direct3DRender::~VS_Direct3DRender()
{
	DeleteSurfaces();
	m_pPSResizer[0] = 0;
	m_pPSResizer[1] = 0;
	m_pPSYUV2RGB = 0;
	m_pScreenSizeTemporaryTexture = NULL;
    m_pD3DDev	= NULL;
	m_pD3DDevEx = NULL;
	m_pD3D = NULL;
	m_pD3DEx = NULL;
}

/**
****************************************************************************
 * \brief Fill info about video driver
 *
 * \param driver				- name of driver dll;
 * \param desc					- driver desc;
 *
 * \date    14-01-2011
 ******************************************************************************/
bool VS_Direct3DRender::FillDeviceInfo(char* driver, char* desc)
{
	D3DADAPTER_IDENTIFIER9 d3di;
	ZeroMemory(&d3di, sizeof(d3di));
	if (m_pD3D && m_pD3D->GetAdapterIdentifier(m_uAdapter, d3di.WHQLLevel, &d3di) == D3D_OK) {
		int Product = HIWORD(d3di.DriverVersion.HighPart);
		int Version = LOWORD(d3di.DriverVersion.HighPart);
		int SubVersion = HIWORD(d3di.DriverVersion.LowPart);
		int Build = LOWORD(d3di.DriverVersion.LowPart);
		char drv_version[128] = {};
		sprintf(drv_version, " version %d.%d.%d.%d",
				HIWORD(d3di.DriverVersion.HighPart), LOWORD(d3di.DriverVersion.HighPart),
				HIWORD(d3di.DriverVersion.LowPart), LOWORD(d3di.DriverVersion.LowPart));
		strncpy(driver, d3di.Driver, MAX_DEVICE_IDENTIFIER_STRING - 1);
		strcat(driver, drv_version);
		strncpy(desc, d3di.Description, MAX_DDDEVICEID_STRING - 1);
		return true;
	}
	return false;
}

void VS_Direct3DRender::GetDirect3DCaps(VS_D3DCAPS *caps)
{
	memset(caps, 0, sizeof(VS_D3DCAPS));
	if (m_pD3D) {
		caps->uGPUPriotity = 7;
		caps->uWidth = m_d3ddm.Width;
		caps->uHeight = m_d3ddm.Height;
		if ((m_caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == D3DDEVCAPS_HWTRANSFORMANDLIGHT) {
			caps->uVertexProcessing = 1;
		} else {
			caps->uVertexProcessing = 0;
		}
		switch (m_d3ddm.Format)
		{
		case D3DFMT_R8G8B8:
			caps->uDepth = 24;
			break;
		case D3DFMT_A8R8G8B8:
		case D3DFMT_X8R8G8B8:
		case D3DFMT_A2B10G10R10:
		case D3DFMT_A8B8G8R8:
		case D3DFMT_X8B8G8R8:
		case D3DFMT_A2R10G10B10:
			caps->uDepth = 32;
			break;
		case D3DFMT_R5G6B5:
		case D3DFMT_X1R5G5B5:
		case D3DFMT_A1R5G5B5:
		case D3DFMT_A4R4G4B4:
		case D3DFMT_A8R3G3B2:
		case D3DFMT_X4R4G4B4:
			caps->uDepth = 16;
			break;
		case D3DFMT_A16B16G16R16:
			caps->uDepth = 64;
			break;
		default: caps->uDepth = 0;
		}
		if (m_pD3DDev) {
			caps->uShaderVerMajor = D3DSHADER_VERSION_MAJOR(m_caps.PixelShaderVersion);
			caps->uShaderVerMinor = D3DSHADER_VERSION_MINOR(m_caps.PixelShaderVersion);
			caps->uTypeShaderResampler = (m_ResizeMode == RM_LANCZOS) ? 1 : 0;
			caps->uMemAvailable = m_pD3DDev->GetAvailableTextureMem();
		}
	}
	strcat(caps->Error, m_cError);
}

UINT VS_Direct3DRender::GetAdapter(IDirect3D9* pD3D, HWND hwnd)
{
	if (hwnd == NULL || pD3D == NULL) {
		return D3DADAPTER_DEFAULT;
	}

	HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
	if (hMonitor == NULL) return D3DADAPTER_DEFAULT;

	UINT adp = 0, num_adp = 0;
	for(adp = 0, num_adp = pD3D->GetAdapterCount(); adp < num_adp; ++adp) {
		HMONITOR hAdpMon = pD3D->GetAdapterMonitor(adp);
		if (hAdpMon == hMonitor) {
			return adp;
		}
	}

	return D3DADAPTER_DEFAULT;
}

bool VS_Direct3DRender::TestD3DCaps(HWND hwnd)
{
	return ResetDevice(hwnd, 320, 240);
}

HRESULT VS_Direct3DRender::CreateDirect3D()
{
	m_pD3DEx = NULL;
	m_pD3D = NULL;

	if (g_pDirect3DCreate9Ex) {
		g_pDirect3DCreate9Ex(D3D_SDK_VERSION, (void**)&m_pD3DEx);
		if (!m_pD3DEx) {
			g_pDirect3DCreate9Ex(D3D9b_SDK_VERSION, (void**)&m_pD3DEx);
		}
	}
	if (!m_pD3DEx) {
		m_pD3D.Attach(Direct3DCreate9(D3D_SDK_VERSION));
		if (!m_pD3D) {
			m_pD3D.Attach(Direct3DCreate9(D3D9b_SDK_VERSION));
		}
		if (!m_pD3D) {
			DTRACE(VSTM_VRND, "don't create Direct3D9");
			return D3DERR_NOTAVAILABLE;
		}
	} else {
		m_pD3D = m_pD3DEx;
	}

	return D3D_OK;
}

HRESULT VS_Direct3DRender::CreateDevice(HWND hwnd)
{
	HRESULT hr;
	DWORD dwVertexProcessing;

    m_pD3DDev = NULL;
	m_pD3DDevEx = NULL;
	m_pPSResizer[0] = 0;
	m_pPSResizer[1] = 0;
	m_pPSYUV2RGB = 0;
	m_pScreenSizeTemporaryTexture = NULL;

	if ((hr = CreateDirect3D()) != D3D_OK) {
		sprintf(m_cError, "failed create Direct3D9\n");
		return hr;
	}

	m_uAdapter = GetAdapter(m_pD3D, hwnd);

	ZeroMemory(&m_d3ddm, sizeof(m_d3ddm));
	if (FAILED(m_pD3D->GetAdapterDisplayMode(m_uAdapter, &m_d3ddm))) {
		DTRACE(VSTM_VRND, "failed GetAdapterDisplayMode");
		sprintf(m_cError, "failed GetAdapterDisplayMode\n");
		return E_UNEXPECTED;
	}

	ZeroMemory(&m_caps, sizeof(m_caps));
	m_pD3D->GetDeviceCaps(m_uAdapter, D3DDEVTYPE_HAL, &m_caps);
    if ((m_caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == D3DDEVCAPS_HWTRANSFORMANDLIGHT) {
        dwVertexProcessing = D3DCREATE_HARDWARE_VERTEXPROCESSING;
    } else {
        dwVertexProcessing = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
    }

	m_RefreshRate = m_d3ddm.RefreshRate;
	m_ScreenSize.SetSize(m_d3ddm.Width, m_d3ddm.Height);

    ZeroMemory(&m_pp, sizeof(m_pp));

	m_pp.Windowed = TRUE;
	m_pp.SwapEffect = D3DSWAPEFFECT_COPY;
	m_pp.hDeviceWindow = hwnd;
	m_pp.Flags = D3DPRESENTFLAG_VIDEO;
	m_pp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
	m_BackbufferType = D3DFMT_X8R8G8B8/*d3ddm.Format*/;
	m_DisplayType = m_d3ddm.Format;

	if (m_pD3DEx) {
		hr = m_pD3DEx->CreateDeviceEx(m_uAdapter, D3DDEVTYPE_HAL, hwnd,
									  dwVertexProcessing | D3DCREATE_MULTITHREADED | D3DCREATE_FPU_PRESERVE, //D3DCREATE_MANAGED
									  &m_pp, NULL, &m_pD3DDevEx);
		if (m_pD3DDevEx) {
			m_pD3DDev = m_pD3DDevEx;
		}
	} else {
		hr = m_pD3D->CreateDevice(m_uAdapter, D3DDEVTYPE_HAL, hwnd,
								  dwVertexProcessing | D3DCREATE_MULTITHREADED | D3DCREATE_FPU_PRESERVE, //D3DCREATE_MANAGED
								  &m_pp, &m_pD3DDev);
	}

	if (m_pD3DDevEx) {
		m_pD3DDevEx->SetGPUThreadPriority(7);
	}

	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create Direct3D Device");
		sprintf(m_cError, "failed create Direct3D Device\n");
		return hr;
	}

	m_filter = D3DTEXF_POINT;

    ZeroMemory(&m_caps, sizeof(m_caps));
	hr = m_pD3DDev->GetDeviceCaps(&m_caps);

	if ( (m_caps.StretchRectFilterCaps & D3DPTFILTERCAPS_MINFLINEAR)
		 && (m_caps.StretchRectFilterCaps & D3DPTFILTERCAPS_MAGFLINEAR) )
	{
		m_filter = D3DTEXF_LINEAR;
	}

	return S_OK;
}

HRESULT VS_Direct3DRender::AllocSurfaces(int width, int height, D3DFORMAT Format)
{
	HRESULT hr;
	int i = 0, j = 0;

	DeleteSurfaces();

	m_SurfaceType = Format;

	/// Create RGB texture
	if (FAILED(hr = m_pD3DDev->CreateTexture(width, height, 1,
											 D3DUSAGE_RENDERTARGET, m_BackbufferType,
											 D3DPOOL_DEFAULT, &m_pVideoTexture, NULL)))
	{
		DTRACE(VSTM_VRND, "failed create RGB texture, format texture %d", m_BackbufferType);
		sprintf(m_cError, "failed create RGB texture\n");
		return hr;
	}
	if (FAILED(hr = m_pVideoTexture->GetSurfaceLevel(0, &m_pVideoSurface))) {
		DTRACE(VSTM_VRND, "failed create RGB surface, format texture %d", m_BackbufferType);
		sprintf(m_cError, "failed create RGB surface\n");
		return hr;
	}
	/// Create YUV444 Texture
	for (i = 0; i < 3; i++) {
		if (FAILED(hr = m_pD3DDev->CreateTexture(width, height, 1,
												 D3DUSAGE_RENDERTARGET, m_BackbufferType,
												 D3DPOOL_DEFAULT, &m_pTextureYUV444[i], NULL)))
		{
			DTRACE(VSTM_VRND, "failed create YUV444 texture");
			sprintf(m_cError, "failed create YUV444 texture\n");
			return hr;
		}
		if (FAILED(hr = m_pTextureYUV444[i]->GetSurfaceLevel(0, &m_pSurfaceYUV444[i]))) {
			DTRACE(VSTM_VRND, "failed create YUV444 surface");
			sprintf(m_cError, "failed create YUV444 surface\n");
			return hr;
		}
	}
	/// Create source I420 Texture D3DFMT_L8
	D3DLOCKED_RECT r;
	unsigned char *pDstBuff;

	for (i = 0; i < 3; i++) {
		if (FAILED(hr = m_pD3DDev->CreateTexture(width, height, 1,
												 D3DUSAGE_DYNAMIC, D3DFMT_L8,
												 D3DPOOL_DEFAULT, &m_pTextureI420[i], NULL)))
		{
			DTRACE(VSTM_VRND, "failed create I420 texture");
			sprintf(m_cError, "failed create I420 texture\n");
			return hr;
		}

		if (i > 0) {
			hr = m_pTextureI420[i]->LockRect(0, &r, NULL, NULL);
			pDstBuff = (unsigned char*)r.pBits;
			for (j = 0; j < height; j++) {
				memset(pDstBuff, 0x80, width);
				pDstBuff += r.Pitch;
			}
			hr = m_pTextureI420[i]->UnlockRect(0);
		}
	}

	hr |= InitResizers();

	return hr;
}

void VS_Direct3DRender::DeleteSurfaces()
{
	m_pVideoTexture = NULL;
	m_pVideoSurface = NULL;
	for (int i = 0; i < 3; i++) {
		m_pTextureI420[i] = NULL;
		m_pTextureYUV444[i] = NULL;
		m_pSurfaceYUV444[i] = NULL;
	}
	m_pNameTexture = NULL;
}

bool VS_Direct3DRender::ResetDevice(HWND hwnd, int width, int height)
{
	HRESULT hr;
	if(FAILED(hr = CreateDevice(hwnd)) || FAILED(hr = AllocSurfaces(width, height))) {
		return false;
	}
	return true;
}

bool VS_Direct3DRender::SetRectangle(HWND hwnd)
{
	if (hwnd == NULL) return false;
	POINT point ={0, 0};
	GetClientRect(hwnd, &m_rPic);
	m_rPic.right = (m_rPic.right + 3)&~3;	// divisible by 4
	m_rPic.bottom = (m_rPic.bottom + 1)&~1;	// divisible by 2
	CopyRect(&m_rViewArea, &m_rPic);
	ClientToScreen(hwnd, &point);
	m_rcb1 = m_rPic;
	m_rcb2 = m_rPic;
	float x = (float)m_biFmtDraw.biWidth/m_rPic.right;
	float y = (float)m_biFmtDraw.biHeight/m_rPic.bottom; // src/dst
	int x_offs = 0;
	int y_offs = 0;
	if (m_bKeepAspectRatio)
		if (x>y)
			y_offs = (int)((m_rPic.bottom - m_rPic.bottom*y/x)/2);
		else if (y>=x)
			x_offs = (int)((m_rPic.right - m_rPic.right*x/y)/2);


	if (y_offs>0) {
		m_rcb1.bottom = y_offs;
		m_rcb2.top = m_rcb2.bottom-y_offs;
		OffsetRect(&m_rcb1, point.x, point.y);
		OffsetRect(&m_rcb2, point.x, point.y);
	}
	else if (x_offs>0) {
		m_rcb1.right = x_offs;
		m_rcb2.left = m_rcb2.right-x_offs;
		OffsetRect(&m_rcb1, point.x, point.y);
		OffsetRect(&m_rcb2, point.x, point.y);
	}
	else {
		SetRectEmpty(&m_rcb1);
		SetRectEmpty(&m_rcb2);
	}
	OffsetRect(&m_rPic, point.x, point.y);
	InflateRect(&m_rPic, -x_offs, -y_offs);
	return true;
}

void VS_Direct3DRender::ClearNonPaintedArea()
{
	if (m_hwnd && m_pD3DDev && m_IsValid) {
		if (!EqualRect(&m_rViewAreaPrev, &m_rDstSci)) {
			RECT r1, r2, rc1;
			if (m_rViewAreaPrev.left != m_rDstSci.left) {
				r1.left = m_rViewAreaPrev.left;
				r1.top = m_rViewAreaPrev.top;
				r1.right = m_rDstSci.left;
				r1.bottom = m_rViewAreaPrev.bottom;

				r2.left = m_rDstSci.right;
				r2.top = m_rViewAreaPrev.top;
				r2.right = m_rViewAreaPrev.right;
				r2.bottom = m_rViewAreaPrev.bottom;
				rc1.left = m_rDstSci.right;
				rc1.top = m_rViewAreaPrev.top;
				rc1.right = m_rViewAreaPrev.right;
				rc1.bottom = m_rViewAreaPrev.bottom;
			} else {
				r1.left = m_rViewAreaPrev.left;
				r1.top = m_rViewAreaPrev.top;
				r1.right = m_rViewAreaPrev.right;
				r1.bottom = m_rDstSci.top;

				r2.left = m_rViewAreaPrev.left;
				r2.top = m_rDstSci.bottom;
				r2.right = m_rViewAreaPrev.right;
				r2.bottom = m_rViewAreaPrev.bottom;

				rc1.left = m_rViewAreaPrev.left;
				rc1.top = m_rDstSci.bottom;
				rc1.right = m_rViewAreaPrev.right;
				rc1.bottom = m_rViewAreaPrev.bottom;
			}
			m_pD3DDev->Present(&rc1, &r1, 0, NULL);
			m_pD3DDev->Present(&rc1, &r2, 0, NULL);
		}
	}
}

int	VS_Direct3DRender::SetMode(eVideoRenderMode Mode, HWND hwnd)
{
	VS_AutoLock lock(this);
	if (!IsInited())
			return 1;

	if (!SetRectangle(hwnd))
		return 0;

	CRect rect;
	SetRect(&rect, 0, 0, m_rPic.right - m_rPic.left, m_rPic.bottom - m_rPic.top);
	int frameSizeMB = rect.right * rect.bottom / 256;
	m_renderFrameSizeMB = frameSizeMB;

	if (!m_IsValid) {
		m_displaydepth = 32;
		m_biFmtDraw.biCompression = BI_RGB;
		m_biFmtDraw.biBitCount	  = m_displaydepth;
		CleanBuffers();

		switch(m_biFmtIn.biCompression)		// input format
		{
		case FCC_I420:
		case FCC_IYUV:
			m_pBufferConvIn = m_pBufferIn;
			break;
		case FCC_I42S:
			m_pBufferConvIn = m_pBufferIn;
			if (m_dwStereoRender > 0) break;
		case FCC_YV12:
		case FCC_YUY2:
		case FCC_UYVY:
		case BI_RGB:
			m_pBufferConvIn = new BYTE[m_width*m_height*3/2];
			m_dwVRUse|=VR_USE_CONVIN;
			break;
		}

		m_pBufferMirrorIn = m_pBufferConvIn;
		if (m_bSelfView && m_bFlipFrame) {
			m_pBufferMirrorIn = new BYTE[m_width*m_height*3/2];
			m_dwVRUse |= VR_USE_FLIP;
		}

		// always use saturate
		m_pBufferSaturated = new BYTE[m_width*m_height*3/2];
		m_dwVRUse|=VR_USE_SATURATE;

		m_biFmtDraw.biWidth = m_width;
		m_biFmtDraw.biHeight = m_height;
		m_pBufferScaled = m_pBufferSaturated;
		m_DrawPitch = m_biFmtDraw.biWidth * m_biFmtDraw.biBitCount / 8;
		SetRect(&m_rPic2, 0, 0, m_biFmtDraw.biWidth, m_biFmtDraw.biHeight);// sourse image dimensions
		m_biFmtDraw.biSizeImage = m_biFmtDraw.biBitCount*m_biFmtDraw.biWidth*m_biFmtDraw.biHeight/8;
		m_pBufferConvOut = new BYTE [m_biFmtDraw.biSizeImage];
		m_pBufferConvOutTmp = new BYTE [m_biFmtDraw.biSizeImage];
		m_dwVRUse|=VR_USE_CONVOUT;	// always

		CopyRect(&m_rDstVid, &rect);
		CopyRect(&m_rDstSci, &rect);
		CopyRect(&rect, &m_rcb1);
		int dx = (rect.Width() == m_rDstVid.right) ? 0 : rect.Width();
		int dy = (rect.Height() == m_rDstVid.bottom) ? 0 : rect.Height();
		OffsetRect(&m_rDstSci, dx, dy);
		CopyRect(&m_rViewAreaPrev, &m_rViewArea);
		if (!ResetDevice(hwnd, m_biFmtDraw.biWidth, m_biFmtDraw.biHeight)) {
			return VRDDERR_CREATESURF;
		}
	} else {
		if (!EqualRect(&m_rViewAreaPrev, &m_rViewArea) || m_hwnd != hwnd) {
			HRESULT hr = D3D_OK;
			CopyRect(&m_rDstVid, &rect);
			CopyRect(&m_rDstSci, &rect);
			CopyRect(&rect, &m_rcb1);
			int dx = (rect.Width() == m_rDstVid.right) ? 0 : rect.Width();
			int dy = (rect.Height() == m_rDstVid.bottom) ? 0 : rect.Height();
			OffsetRect(&m_rDstSci, dx, dy);
			GetClientRect(hwnd, &rect);
			m_pp.BackBufferWidth = rect.Width();
			m_pp.BackBufferHeight = rect.Height();
			m_pp.hDeviceWindow = hwnd;
			hr |= m_pD3DDev->Reset(&m_pp);
			hr |= AllocSurfaces(m_biFmtDraw.biWidth, m_biFmtDraw.biHeight);
			if (FAILED(hr)) {
				DTRACE(VSTM_VRND, "failed reinit d3d");
				m_IsValid = false;
				return 1;
			}
			CopyRect(&m_rViewAreaPrev, &m_rViewArea);
		}
	}

	m_RenderMode = Mode;
	m_bNewFrame = 1;
	m_IsValid = true;
	m_hwnd = hwnd;
	return 0;
}

bool VS_Direct3DRender::PrepareFrame(HWND hwnd)
{
	HRESULT hRet = D3D_OK;
	bool sucs = true;

	if (m_bNewFrame) {

		/// Load YUV Texture
		int i = 0, j = 0;
		RECT rect(m_rPic2);
		D3DLOCKED_RECT r;
		unsigned char *pSrcBuff;
		unsigned char *pDstBuff;

		if (m_dwVRUse & VR_USE_CONVIN) if (!ConvertColorSpaceIn()) return false;
		if (m_dwVRUse & VR_USE_FLIP) if (!MirrorVertical()) return false;

		pSrcBuff = m_pBufferMirrorIn;

		hRet = m_pD3DDev->ColorFill(m_pVideoSurface, NULL, 0);
		for (j = 0; j < 3; j++) {
			hRet = m_pD3DDev->ColorFill(m_pSurfaceYUV444[j], NULL, D3DCOLOR_XRGB(128, 128, 128));

			if (j == 1) {
				rect.bottom >>= 1;
				rect.right  >>= 1;
			}

			hRet = m_pTextureI420[j]->LockRect(0, &r, NULL, NULL);
			if (FAILED(hRet)) {
				DTRACE(VSTM_VRND, "Can't lock texture");
				return false;
			}

			pDstBuff = (unsigned char*)r.pBits;
			for (i = 0; i < rect.bottom; i++) {
				memcpy(pDstBuff, pSrcBuff, rect.right);
				pDstBuff += r.Pitch;
				pSrcBuff += rect.right;
			}

			hRet = m_pTextureI420[j]->UnlockRect(0);
		}
		CreateTextureName(m_rViewAreaPrev.right - m_rViewAreaPrev.left, m_rViewAreaPrev.bottom - m_rViewAreaPrev.top);
		m_bNewFrame = FALSE;
	}

	return sucs;
}

int VS_Direct3DRender::DrawFrame(HWND hwnd)
{
	VS_AutoLock lock(this);

	//AUTO_PROF

	if (!IsInited()) return 1;

	if (m_DrawBorders)
		DrawBorders();

	if (!m_IsValid) { // try to repair if render cannot draw
		DWORD currTime = timeGetTime();
		if (currTime - m_repairTime >= VR_REPAIR_TIME) {
			m_repairTime = currTime;
			SetMode(VRM_DEFAULT, hwnd);
		}
		if (!m_IsValid) return 1;
	}

	if (hwnd!=m_hwnd || m_bForceBicubicChange!=m_bForceBicubic) {
		m_RenderMode = VRM_UNDEF;
		m_bForceBicubicChange = m_bForceBicubic;
		if (SetMode(VRM_DEFAULT, hwnd)) return 1;
	}

	HRESULT hRet;

	if (!SetRectangle(hwnd)) return 1;

	if (!IsWindowVisible(m_hwnd)) return 0;

	if (FAILED(hRet = m_pD3DDev->BeginScene())) return 1;

	CComPtr<IDirect3DSurface9> pBackBuffer;
	hRet |= m_pD3DDev->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
	hRet |= m_pD3DDev->SetRenderTarget(0, pBackBuffer);
	hRet |= m_pD3DDev->Clear(0, NULL, D3DCLEAR_TARGET, 0, 1.0f, 0);

	if (!PrepareFrame(hwnd)) return 1;

	CComPtr<IDirect3DSurface9> pRT;
	hRet |= m_pD3DDev->GetRenderTarget(0, &pRT);

	hRet |= ConvertI420toYUV444(m_pTextureI420, m_pSurfaceYUV444, m_rPic2);
	hRet |= ConvertYUV444toRGBA(m_pTextureYUV444, m_pVideoSurface, m_rPic2, (float)m_dwSaturation);

	hRet |= m_pD3DDev->SetRenderTarget(0, pRT);

	vector3D dst[4];
	SetTransform(m_rDstVid, dst);

	if (!EqualRect(&m_rDstVid, &m_rPic2)) {
		hRet |= ResamplingRGBA(m_pVideoTexture, dst, m_rPic2);
	} else {
		hRet |= TextureResize(m_pVideoTexture, dst, D3DTEXF_POINT, m_rPic2);
	}

	if (!IsRectEmpty(&m_DisplayName.rName)) {
		hRet |= DrawDisplayName(m_pNameTexture, m_DisplayName.rName);
	}

	hRet |= m_pD3DDev->EndScene();

	hRet |= m_pD3DDev->Present(NULL, NULL, NULL, NULL);

	if (hRet == D3DERR_DEVICELOST) {
		hRet = m_pD3DDev->TestCooperativeLevel();
		if (hRet == D3DERR_DEVICELOST) {
			return false;
		} else if (hRet == D3DERR_DEVICENOTRESET) {
			hRet = m_pD3DDev->Reset(&m_pp);
			if (SUCCEEDED(hRet)) {
				DeleteSurfaces();
				hRet = AllocSurfaces(m_biFmtDraw.biWidth, m_biFmtDraw.biHeight);
				if (FAILED(hRet)) {
					return false;
				}
			}
		}
	}

	return hRet != D3D_OK;
}

HRESULT VS_Direct3DRender::TextureBlt(CustomVertex3D v[4], D3DTEXTUREFILTERTYPE filter, int iTexturesCoord)
{
	HRESULT hr;

    hr = m_pD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    hr = m_pD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA|D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_RED);

	for (int i = 0; i < iTexturesCoord; i++) {
		hr = m_pD3DDev->SetSamplerState(i, D3DSAMP_MAGFILTER, filter);
		hr = m_pD3DDev->SetSamplerState(i, D3DSAMP_MINFILTER, filter);
		hr = m_pD3DDev->SetSamplerState(i, D3DSAMP_MIPFILTER, filter);

		hr = m_pD3DDev->SetSamplerState(i, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
		hr = m_pD3DDev->SetSamplerState(i, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
	}

	for (int i = 0; i < iTexturesCoord; i++) {
		hr = m_pD3DDev->SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, 0);
	}

	hr = m_pD3DDev->SetFVF(D3DFVF_XYZRHW | D3DFVF_TEX1);

	CustomVertex3D tmp = v[2]; v[2] = v[3]; v[3] = tmp;
	hr = m_pD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, v, sizeof(v[0]));

	for (int i = 0; i < iTexturesCoord; i++) {
		m_pD3DDev->SetTexture(i, NULL);
	}

	return S_OK;
}

HRESULT VS_Direct3DRender::TextureAlphaBlt(CustomVertex3D v[4], D3DTEXTUREFILTERTYPE filter)
{
	HRESULT hr;

    hr = m_pD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	hr = m_pD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	hr = m_pD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	hr = m_pD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	hr = m_pD3DDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
	hr = m_pD3DDev->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA|D3DCOLORWRITEENABLE_BLUE|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_RED);

	hr = m_pD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, filter);
	hr = m_pD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, filter);
	hr = m_pD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, filter);

	hr = m_pD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
	hr = m_pD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);

	hr = m_pD3DDev->SetFVF(D3DFVF_XYZRHW | D3DFVF_TEX1);

	CustomVertex3D tmp = v[2]; v[2] = v[3]; v[3] = tmp;
	hr = m_pD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, v, sizeof(v[0]));

	m_pD3DDev->SetTexture(0, NULL);

	hr = m_pD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

	return S_OK;
}

void VS_Direct3DRender::SetTransform(CRect r, vector3D v[4])
{
	v[0].x = (float)r.left; v[0].y = (float)r.top; v[0].z = 0.5;
	v[1].x = (float)r.right; v[1].y = (float)r.top; v[1].z = 0.5;
	v[2].x = (float)r.left; v[2].y = (float)r.bottom; v[2].z = 0.5;
	v[3].x = (float)r.right; v[3].y = (float)r.bottom; v[3].z = 0.5;
}

void VS_Direct3DRender::SetVertex(CustomVertex3D *vertex, vector3D vct, float u, float v)
{
	vertex->x = vct.x; vertex->y = vct.y; vertex->z = vct.z;
	vertex->rhw = 1.0f / vct.z;
	vertex->u = u; vertex->v = v;
}

void VS_Direct3DRender::SetVertex(CustomVertex3D *vertex, float x, float y, float z, float u, float v)
{
	vertex->x = x; vertex->y = y; vertex->z = z;
	vertex->rhw = 1.0f / z;
	vertex->u = u; vertex->v = v;
}

void VS_Direct3DRender::AdjustVertex(CustomVertex3D *vertex, float dx, float dy)
{
	float offset = 0.5;

	for (int i = 0; i < 4; i++) {
		vertex[i].x -= offset;
		vertex[i].y -= offset;
		vertex[i].u -= offset * dx;
		vertex[i].v -= offset * dy;
	}
}

HRESULT VS_Direct3DRender::TextureResize(CComPtr<IDirect3DTexture9> pTexture, vector3D vct[4], D3DTEXTUREFILTERTYPE filter, const CRect &SrcRect)
{
	HRESULT hr;

	D3DSURFACE_DESC desc;
	if (!pTexture || FAILED(pTexture->GetLevelDesc(0, &desc)))
		return E_FAIL;

	float w = (float)desc.Width;
	float h = (float)desc.Height;

	float dx = 1.0f/w;
	float dy = 1.0f/h;
	float dx2 = 1.0f/w;
	float dy2 = 1.0f/h;

	if (filter == D3DTEXF_POINT) {
		vct[0].x += m_rDstSci.left;
		vct[1].x += m_rDstSci.left;
		vct[2].x += m_rDstSci.left;
		vct[3].x += m_rDstSci.left;
		vct[0].y += m_rDstSci.top;
		vct[1].y += m_rDstSci.top;
		vct[2].y += m_rDstSci.top;
		vct[3].y += m_rDstSci.top;
	}

	CustomVertex3D v[4];

	SetVertex(&v[0], vct[0], SrcRect.left * dx2, SrcRect.top * dy2);
	SetVertex(&v[1], vct[1], SrcRect.right * dx2, SrcRect.top * dy2);
	SetVertex(&v[2], vct[2], SrcRect.left * dx2, SrcRect.bottom * dy2);
	SetVertex(&v[3], vct[3], SrcRect.right * dx2, SrcRect.bottom * dy2);

	AdjustVertex(v, 0, 0);

	hr = m_pD3DDev->SetTexture(0, pTexture);

	hr = m_pD3DDev->SetPixelShader(NULL);

	hr = TextureBlt(v, filter);

	return hr;
}

HRESULT VS_Direct3DRender::ConvertI420toYUV444(CComPtr<IDirect3DTexture9> pSrcTexture[3], CComPtr<IDirect3DSurface9> pDstSurface[3], const CRect &SrcRect)
{
	HRESULT hr;
	D3DSURFACE_DESC desc;
	vector3D vct[4];

	if (!pSrcTexture[0] || !pDstSurface[0] || FAILED(pSrcTexture[0]->GetLevelDesc(0, &desc)))
		return E_FAIL;

	RECT UVRect(SrcRect);
	UVRect.bottom >>= 1;
	UVRect.right >>= 1;

	SetTransform(SrcRect, vct);

	hr = m_pD3DDev->SetRenderTarget(0, pDstSurface[0]);
	TextureResize(pSrcTexture[0], vct, D3DTEXF_LINEAR, SrcRect);

	if(!pSrcTexture[1] || !pDstSurface[1] || !pSrcTexture[2] || !pDstSurface[2])
		return E_FAIL;

	hr = m_pD3DDev->SetRenderTarget(0, pDstSurface[1]);
	TextureResize(pSrcTexture[1], vct, D3DTEXF_LINEAR, UVRect);
	hr = m_pD3DDev->SetRenderTarget(0, pDstSurface[2]);
	TextureResize(pSrcTexture[2], vct, D3DTEXF_LINEAR, UVRect);

	hr = m_pD3DDev->SetPixelShader(NULL);

	return hr;
}

HRESULT VS_Direct3DRender::ConvertYUV444toRGBA(CComPtr<IDirect3DTexture9> pSrcTexture[3], CComPtr<IDirect3DSurface9> pDstSurface, const CRect &SrcRect, float saturation)
{
	HRESULT hr;

	D3DSURFACE_DESC desc;
	if(!pSrcTexture || !pDstSurface || FAILED(pSrcTexture[0]->GetLevelDesc(0, &desc)))
		return E_FAIL;

	float w = (float)desc.Width;
	float h = (float)desc.Height;

	float fConstData[][4] = {{(float)saturation, 0, 0, 0}};
	hr = m_pD3DDev->SetPixelShaderConstantF(0, (float*)fConstData, 1);

	hr = m_pD3DDev->SetRenderTarget(0, pDstSurface);
	hr = m_pD3DDev->SetPixelShader(m_pPSYUV2RGB);

	CustomVertex3D v[4];

	float d = 0.1f;

	SetVertex(&v[0], 0, 0, 0.5f, 0, 0);
	SetVertex(&v[1], w, 0, 0.5f, 1, 0);
	SetVertex(&v[2], 0, h, 0.5f, 0, 1);
	SetVertex(&v[3], w, h, 0.5f, 1, 1);

	AdjustVertex(v, 0.0, 0.0);

	hr = m_pD3DDev->SetTexture(0, pSrcTexture[0]);
	hr = m_pD3DDev->SetTexture(1, pSrcTexture[1]);
	hr = m_pD3DDev->SetTexture(2, pSrcTexture[2]);
	hr = TextureBlt(v, D3DTEXF_LINEAR, 3);

	hr = m_pD3DDev->SetPixelShader(NULL);

	return hr;
}

HRESULT VS_Direct3DRender::ResamplingRGBA(CComPtr<IDirect3DTexture9> pTexture, vector3D dst[4], const CRect &SrcRect)
{
	HRESULT hr;

	D3DSURFACE_DESC desc;
	if (!pTexture || FAILED(pTexture->GetLevelDesc(0, &desc))) {
		return E_FAIL;
	}

	float Tex0_Width = (float)desc.Width;
	float Tex0_Height = (float)desc.Height;

	double dx0 = 1.0/(double)desc.Width;
	double dy0 = 1.0/(double)desc.Height;

	CSize SrcTextSize = CSize(desc.Width, desc.Height);
	double w = (double)SrcRect.Width();
	double h = (double)SrcRect.Height();

	CRect dst1(0, 0, (int)(dst[3].x - dst[0].x), (int)h);

	if (!m_pScreenSizeTemporaryTexture || FAILED(m_pScreenSizeTemporaryTexture->GetLevelDesc(0, &desc))) {
		return E_FAIL;
	}

	float Tex1_Width = (float)desc.Width;
	float Tex1_Height = (float)desc.Height;

	double dx1 = 1.0/(double)desc.Width;
	double dy1 = 1.0/(double)desc.Height;

	double dw = (double)dst1.Width() / (double)desc.Width;
	double dh = (double)dst1.Height() / (double)desc.Height;

	float dx2 = 1.0f/(float)SrcTextSize.cx;
	float dy2 = 1.0f/(float)SrcTextSize.cy;
	float tx0 = (float)SrcRect.left;
	float tx1 = (float)SrcRect.right;
	float ty0 = (float)SrcRect.top;
	float ty1 = (float)SrcRect.bottom;

	float tx0_2 = 0.0f;
	float tx1_2 = (float)dst1.Width();
	float ty0_2 = 0.0f;
	float ty1_2 = (float)h;

	CustomVertex3D vx[4], vy[4];

	SetVertex(&vx[0], (float)dst1.left, (float)dst1.top, 0.5f, tx0, ty0);
	SetVertex(&vx[1], (float)dst1.right, (float)dst1.top, 0.5f, tx1, ty0);
	SetVertex(&vx[2], (float)dst1.left, (float)dst1.bottom, 0.5f, tx0, ty1);
	SetVertex(&vx[3], (float)dst1.right, (float)dst1.bottom, 0.5f, tx1, ty1);

	AdjustVertex(vx, 1.0, 0.0);

	{
		dst[0].x += m_rDstSci.left;
		dst[1].x += m_rDstSci.left;
		dst[2].x += m_rDstSci.left;
		dst[3].x += m_rDstSci.left;
		dst[0].y += m_rDstSci.top;
		dst[1].y += m_rDstSci.top;
		dst[2].y += m_rDstSci.top;
		dst[3].y += m_rDstSci.top;
	}

	SetVertex(&vy[0], dst[0], tx0_2, ty0_2);
	SetVertex(&vy[1], dst[1], tx1_2, ty0_2);
	SetVertex(&vy[2], dst[2], tx0_2, ty1_2);
	SetVertex(&vy[3], dst[3], tx1_2, ty1_2);

	AdjustVertex(vy, 0.0, 1.0);

	hr = m_pD3DDev->SetPixelShader(m_pPSResizer[0]);
	{
		float fConstData[][4] = {{0.5f / Tex0_Width, 0.5f / Tex0_Height, 0, 0}, {1.0f / Tex0_Width, 1.0f / Tex0_Height, 0, 0}, {1.0f / Tex0_Width, 0, 0, 0}, {0, 1.0f / Tex0_Height, 0, 0}, {Tex0_Width, Tex0_Height, 0, 0}};
		hr = m_pD3DDev->SetPixelShaderConstantF(0, (float*)fConstData, 5);
	}

	hr = m_pD3DDev->SetTexture(0, pTexture);

	CComPtr<IDirect3DSurface9> pRTOld;
	hr = m_pD3DDev->GetRenderTarget(0, &pRTOld);

	CComPtr<IDirect3DSurface9> pRT;
	hr = m_pScreenSizeTemporaryTexture->GetSurfaceLevel(0, &pRT);
	hr = m_pD3DDev->SetRenderTarget(0, pRT);

	hr = TextureBlt(vx, D3DTEXF_POINT);

	hr = m_pD3DDev->SetPixelShader(m_pPSResizer[1]);
	{
		float fConstData[][4] = {{0.5f / Tex1_Width, 0.5f / Tex1_Height, 0, 0}, {1.0f / Tex1_Width, 1.0f / Tex1_Height, 0, 0}, {1.0f / Tex1_Width, 0, 0, 0}, {0, 1.0f / Tex1_Height, 0, 0}, {Tex1_Width, Tex1_Height, 0, 0}};
		hr = m_pD3DDev->SetPixelShaderConstantF(0, (float*)fConstData, 5);
	}

	hr = m_pD3DDev->SetTexture(0, m_pScreenSizeTemporaryTexture);

	hr = m_pD3DDev->SetRenderTarget(0, pRTOld);

	hr = TextureBlt(vy, D3DTEXF_POINT);

	m_pD3DDev->SetPixelShader(NULL);

	return hr;
}

HRESULT VS_Direct3DRender::DrawDisplayName(CComPtr<IDirect3DTexture9> pTextureText, const CRect &SrcRect)
{
	HRESULT hr;

	hr = m_pD3DDev->SetPixelShader(NULL);

	CustomVertex3D v[4];

	int w = SrcRect.Width();
	int h = SrcRect.Height();

	SetVertex(&v[0], 0.0f, 0.0f, 0.5f, 0.0f, 0.0f);
	SetVertex(&v[1], (float)w, 0.0f, 0.5f, 1.0f, 0.0f);
	SetVertex(&v[2], 0.0f, (float)h, 0.5f, 0.0f, 1.0f);
	SetVertex(&v[3], (float)w, (float)h, 0.5f, 1.0f, 1.0f);

	AdjustVertex(v, 0.0f, 0.0f);

	hr = m_pD3DDev->SetTexture(0, pTextureText);

	hr = TextureAlphaBlt(v, D3DTEXF_LINEAR);

	return hr;
}

static unsigned char ps_resampler_bicubic[] =
{
	0xa0, 0x04, 0x00, 0x00, 0x0a, 0x8e, 0xbe, 0x2b, 0x4f, 0x68, 0xae, 0x5a, 0xc6, 0x57, 0xcd, 0x08,
	0xff, 0x6a, 0x4e, 0x8a, 0xa7, 0x8b, 0x87, 0x36, 0xcd, 0xa8, 0x03, 0x63, 0x24, 0xd4, 0x5e, 0x6a,
	0x23, 0x7a, 0x6e, 0x8e, 0x3c, 0xd5, 0x91, 0x05, 0x02, 0x69, 0xe2, 0x40, 0x8e, 0x98, 0xb9, 0xc7,
	0x99, 0x08, 0x4d, 0xdb, 0x58, 0x6f, 0x2e, 0x37, 0x8f, 0x16, 0x59, 0x29, 0xd3, 0xe3, 0x76, 0x41,
	0x64, 0x09, 0x56, 0xd7, 0x1e, 0xd8, 0x3e, 0xba, 0x01, 0x91, 0x22, 0xb4, 0x0c, 0xaf, 0xc0, 0x6b,
	0xb3, 0xbf, 0x2a, 0xc7, 0x8b, 0x8b, 0x08, 0x34, 0x5b, 0x46, 0x57, 0x95, 0xbe, 0x7d, 0xa9, 0x38,
	0xdd, 0x24, 0xce, 0xcc, 0xe1, 0x9b, 0x85, 0xf8, 0xea, 0xc6, 0xcc, 0x0f, 0x48, 0x2c, 0xbf, 0xd6,
	0x68, 0xf2, 0x99, 0xb9, 0xe6, 0x00, 0x43, 0xe5, 0x43, 0x7f, 0x4e, 0xc9, 0x17, 0x61, 0xa6, 0x51,
	0xeb, 0x54, 0xa7, 0x29, 0x6e, 0xf6, 0x92, 0x24, 0xdc, 0xae, 0xdd, 0x41, 0xe3, 0x80, 0x6a, 0x5a,
	0x0a, 0xe0, 0x76, 0xc6, 0x68, 0xc2, 0xce, 0xd5, 0x0d, 0xfd, 0xe4, 0xd0, 0x73, 0xe0, 0xd5, 0x68,
	0xe1, 0xbe, 0x8a, 0xa2, 0xa5, 0xd0, 0xe3, 0xbf, 0xe6, 0x8e, 0xab, 0x9a, 0xd7, 0x8c, 0xaf, 0x35,
	0x72, 0x76, 0xc3, 0x47, 0x0c, 0xfd, 0xdb, 0xcf, 0x5d, 0xf6, 0xdd, 0x14, 0xe5, 0x28, 0x35, 0x25,
	0x4e, 0x0d, 0x49, 0xea, 0x65, 0x9d, 0x11, 0xb6, 0x56, 0x9e, 0xea, 0x76, 0xf7, 0xd2, 0x1f, 0xba,
	0xc2, 0x51, 0x5f, 0x8c, 0x1b, 0x6c, 0xd5, 0xa7, 0x33, 0xef, 0x8c, 0x75, 0xa1, 0x1f, 0x51, 0x11,
	0xf5, 0x6d, 0xfa, 0xfa, 0x87, 0x6d, 0xed, 0x83, 0xf1, 0xa7, 0x83, 0x0a, 0x8a, 0xde, 0x55, 0x87,
	0xbe, 0x3a, 0x30, 0x1f, 0x2e, 0xab, 0x75, 0x44, 0x50, 0x35, 0xfa, 0x23, 0x84, 0xae, 0x9e, 0x24,
	0x38, 0x73, 0x49, 0x32, 0xa0, 0x8a, 0x99, 0x9a, 0x73, 0xd8, 0xe3, 0x1e, 0xa2, 0x8b, 0xe7, 0x48,
	0x25, 0x1b, 0xea, 0xdb, 0x40, 0x17, 0x63, 0xf4, 0x82, 0xe5, 0x6b, 0x1c, 0x43, 0x9c, 0x85, 0xca,
	0x0a, 0xe6, 0x1b, 0x2a, 0xba, 0xba, 0xb0, 0xaf, 0x68, 0xc0, 0xc0, 0x58, 0x7c, 0xf5, 0x3e, 0x08,
	0xd5, 0x64, 0x1b, 0xaf, 0xe6, 0xe0, 0x4c, 0x3e, 0xf8, 0x48, 0x68, 0x8b, 0x77, 0x79, 0x04, 0xeb,
	0x2b, 0xff, 0x82, 0x7a, 0xda, 0x53, 0x6f, 0x72, 0xc2, 0xa5, 0xf2, 0x60, 0xc0, 0x17, 0x18, 0x8d,
	0x67, 0x19, 0xec, 0x89, 0x12, 0x87, 0xf3, 0x43, 0x43, 0xb9, 0x5c, 0xff, 0xa4, 0x06, 0xbb, 0xfd,
	0xe9, 0xca, 0x93, 0x8b, 0xc2, 0xba, 0x8e, 0xc3, 0x75, 0x6c, 0xb3, 0x0e, 0x92, 0xe2, 0xf9, 0xc2,
	0xef, 0xef, 0x7c, 0x04, 0x1f, 0x61, 0x4b, 0xb0, 0x4c, 0x6d, 0x9d, 0xb6, 0x85, 0x42, 0x14, 0x89,
	0xe7, 0xd9, 0x43, 0xc4, 0x8c, 0x0c, 0x65, 0x95, 0x80, 0xe5, 0xc7, 0x49, 0xf2, 0x16, 0xa6, 0x34,
	0xb6, 0xc7, 0x27, 0xe0, 0xe9, 0x0f, 0x21, 0x15, 0xc0, 0xab, 0xf2, 0x33, 0xd2, 0x5b, 0x8b, 0x40,
	0x77, 0x0c, 0xa3, 0x78, 0x7a, 0x01, 0x2c, 0x4b, 0xe6, 0xd6, 0xb0, 0xdb, 0xfa, 0x45, 0x06, 0x79,
	0x65, 0x50, 0xe3, 0xf4, 0x9e, 0xac, 0xbd, 0x9d, 0xc5, 0x18, 0x1f, 0x67, 0xc3, 0x43, 0x66, 0xaf,
	0xe4, 0x3b, 0x7e, 0x32, 0x4f, 0xf1, 0xce, 0x43, 0xe1, 0xac, 0xa8, 0xe4, 0x36, 0xb3, 0xd9, 0xcf,
	0x84, 0x49, 0x42, 0x9b, 0xda, 0xe6, 0xc3, 0x46, 0x10, 0x14, 0x1c, 0x9a, 0xf2, 0xca, 0x3d, 0xf9,
	0x7f, 0xb7, 0x62, 0xa9, 0xd9, 0x09, 0x45, 0x9a, 0xd5, 0xd2, 0x9a, 0x36, 0xb7, 0x47, 0xd3, 0xd2,
	0xeb, 0xcf, 0x7a, 0x46, 0xda, 0x99, 0xfe, 0x4b, 0x69, 0xda, 0xfd, 0xa6, 0x4b, 0x20, 0xcd, 0x8f,
	0x2c, 0x54, 0xd7, 0xf9, 0xda, 0x5c, 0x22, 0x56, 0x92, 0x4c, 0x05, 0x3d, 0xf4, 0x60, 0xd9, 0x08,
	0xe8, 0x1c, 0x5a, 0x14, 0x5d, 0x78, 0x16, 0xa6, 0x7c, 0xbe, 0x3c, 0xe8, 0x1d, 0x3d, 0x04, 0x42,
	0x89, 0xc9, 0x19, 0xfe, 0x50, 0xfa, 0xed, 0x1c, 0xb9, 0x5e, 0x3e, 0xbc, 0xb3, 0xa2, 0x8a, 0xac,
	0x0b, 0x1c, 0x77, 0xf4, 0x18, 0xf8, 0x80, 0xa1, 0x2c, 0x30, 0xd5, 0x19, 0x67, 0x42, 0x43, 0x48,
	0x9c, 0x48, 0xe1, 0x05, 0x41, 0x41, 0xde, 0xba, 0xf9, 0x24, 0xfd, 0x0e, 0x8d, 0x1f, 0xbe, 0x42,
	0xd2, 0x7a, 0xa0, 0x0f, 0xd2, 0x21, 0x9c, 0x20, 0x5a, 0xb8, 0x9e, 0xa2, 0xb4, 0xb8, 0x67, 0xda,
	0xb7, 0x9f, 0xcf, 0x4c, 0x62, 0xe0, 0x24, 0x49, 0xbd, 0xe0, 0xf2, 0x5f, 0xee, 0x46, 0xc7, 0x72,
	0x40, 0xd2, 0x13, 0xb7, 0x5a, 0x7c, 0x3c, 0x6e, 0xd9, 0x64, 0xd1, 0x43, 0x66, 0x13, 0x39, 0x80,
	0x92, 0xfa, 0xa1, 0xcf, 0x77, 0x59, 0xbf, 0x77, 0x85, 0xe8, 0x7b, 0xf9, 0x83, 0xb9, 0x43, 0xae,
	0x95, 0xd6, 0xf0, 0x77, 0x18, 0x5e, 0xc5, 0x25, 0xf7, 0x8c, 0x3f, 0x53, 0x68, 0x7d, 0x2e, 0x41,
	0xb2, 0xea, 0x61, 0xc2, 0x2b, 0x15, 0xcf, 0x59, 0x94, 0x39, 0xbe, 0x42, 0x56, 0x5a, 0x6a, 0xfc,
	0x98, 0x75, 0x45, 0x9c, 0x47, 0x0b, 0xc0, 0x9e, 0x1e, 0x92, 0x97, 0x26, 0x72, 0xef, 0x55, 0xe8,
	0xfe, 0x6d, 0xcd, 0x22, 0xd5, 0x54, 0xa0, 0x7a, 0x88, 0xbc, 0x6f, 0xd5, 0x08, 0x8d, 0x52, 0x8f,
	0x23, 0x8a, 0x24, 0xd7, 0x07, 0x7b, 0x43, 0x7b, 0xca, 0xe7, 0x89, 0xda, 0x17, 0x64, 0xe0, 0x1d,
	0x1c, 0xd5, 0xc9, 0x02, 0x54, 0xa9, 0x35, 0xe6, 0x23, 0x68, 0x8d, 0xc5, 0xdd, 0x6e, 0xd0, 0x87,
	0xff, 0x20, 0xff, 0x43, 0x87, 0xc5, 0xce, 0xda, 0x0d, 0x29, 0x7c, 0xec, 0xf8, 0xb8, 0x2c, 0x60,
	0x38, 0x84, 0x6a, 0xaf, 0xcb, 0xeb, 0xa4, 0x31, 0x99, 0x66, 0xf4, 0x34, 0x0f, 0xd2, 0x8f, 0x0c,
	0x6e, 0xc7, 0x51, 0x3f, 0xca, 0x61, 0xb1, 0xcc, 0x8b, 0xae, 0x8b, 0x20, 0xf6, 0xf0, 0x3f, 0x17,
	0x95, 0x42, 0x9f, 0x9c, 0xd9, 0xad, 0xdf, 0x98, 0x6e, 0xe3, 0x94, 0x53, 0xed, 0x7e, 0x8f, 0xf3,
	0x94, 0xae, 0x40, 0xb9, 0x59, 0x69, 0xf4, 0x0f, 0xff, 0x1d, 0xbd, 0x8f, 0xc1, 0x00
};

static unsigned char ps_resampler_lanczos[] =
{
	0xcc, 0x09, 0x00, 0x00, 0x0a, 0x8e, 0xbe, 0x2b, 0x4f, 0x68, 0xae, 0x5a, 0xc6, 0x57, 0xcd, 0x09,
	0x02, 0xff, 0x5e, 0x93, 0x12, 0x42, 0x45, 0xd1, 0x61, 0x93, 0x30, 0x39, 0x41, 0x00, 0x70, 0x92,
	0x62, 0x0c, 0x65, 0xc1, 0xb8, 0xb3, 0x64, 0x04, 0x30, 0x0e, 0x33, 0x55, 0x01, 0xaa, 0x62, 0xd2,
	0x63, 0xec, 0x48, 0xe0, 0xf6, 0xba, 0xb6, 0xdb, 0xcd, 0xce, 0xee, 0x85, 0x64, 0x50, 0xf7, 0x26,
	0x6e, 0x91, 0x92, 0xcf, 0x78, 0xd0, 0xc8, 0x0d, 0x30, 0x47, 0xbc, 0x82, 0xcd, 0x2f, 0x83, 0xa5,
	0x87, 0xd9, 0x3d, 0xdb, 0x62, 0xbd, 0x64, 0x47, 0xa6, 0xd0, 0x83, 0xc3, 0x5a, 0x2b, 0x8e, 0xae,
	0x2d, 0xf0, 0x2d, 0xf5, 0xf9, 0x0d, 0xb5, 0x0c, 0xf3, 0x3c, 0xcf, 0x08, 0x97, 0xed, 0x2a, 0x78,
	0x7c, 0xaf, 0x34, 0x1f, 0x66, 0xbe, 0xa5, 0x9f, 0x29, 0xd9, 0x75, 0xc7, 0xa1, 0x97, 0x50, 0xed,
	0xba, 0xfe, 0x2d, 0x0d, 0x2c, 0x57, 0xd0, 0x3c, 0xf7, 0x18, 0x23, 0xe8, 0xa4, 0xa1, 0xc4, 0x76,
	0xea, 0x0b, 0x9b, 0x37, 0x2a, 0x32, 0x26, 0x8e, 0xc1, 0xb2, 0xfe, 0x20, 0x82, 0xe1, 0x7b, 0x3d,
	0x0a, 0x11, 0x21, 0x72, 0x7f, 0x29, 0xee, 0x67, 0xd7, 0x06, 0xa7, 0xcf, 0x63, 0x1d, 0x6f, 0x43,
	0xb7, 0x01, 0x25, 0xe0, 0xd0, 0xf1, 0x03, 0x73, 0x50, 0x2a, 0xa0, 0x96, 0x8b, 0xb6, 0xa2, 0x1d,
	0xc3, 0x4a, 0x87, 0x4f, 0x1f, 0x09, 0xf0, 0x4e, 0x04, 0xba, 0xa3, 0xe2, 0xd8, 0x5e, 0x04, 0x59,
	0x6c, 0x20, 0x83, 0xaa, 0xf7, 0x7b, 0x6e, 0x11, 0x20, 0xe2, 0xa7, 0x88, 0x8d, 0xb1, 0xfa, 0xf8,
	0xd0, 0x6a, 0x4c, 0x07, 0x96, 0x05, 0x44, 0x68, 0xd3, 0x6c, 0x4f, 0x9f, 0x84, 0xec, 0x5b, 0xa5,
	0x49, 0x27, 0x24, 0x27, 0x3e, 0x3c, 0x68, 0x3d, 0x4c, 0x1c, 0x07, 0x2b, 0x10, 0x1e, 0xa6, 0x86,
	0x5d, 0x26, 0x59, 0x83, 0x2f, 0x60, 0xab, 0xa4, 0x9a, 0x0c, 0x1e, 0x3b, 0xbb, 0xe0, 0xbc, 0x50,
	0x4e, 0xff, 0x10, 0x65, 0x22, 0x2b, 0x25, 0x48, 0x9b, 0xd2, 0x1a, 0x04, 0xe1, 0xd6, 0xbb, 0xcf,
	0xde, 0x1a, 0x4d, 0xaa, 0x2f, 0x65, 0x30, 0x00, 0xb3, 0xd3, 0x8d, 0x34, 0x25, 0x35, 0x7d, 0x0e,
	0x3a, 0x5b, 0x6e, 0xba, 0xd2, 0x29, 0xa6, 0x0b, 0x38, 0xdc, 0xf1, 0xd1, 0xce, 0x78, 0xc1, 0x0d,
	0xbc, 0x63, 0xcc, 0x80, 0x37, 0x7c, 0x2f, 0x07, 0xa0, 0x36, 0xe6, 0xb3, 0x29, 0x13, 0x7a, 0x30,
	0xa0, 0x2c, 0xf9, 0xb2, 0x11, 0x17, 0x2c, 0x4a, 0x49, 0xb5, 0x6a, 0x7a, 0xb6, 0x91, 0xd0, 0xe8,
	0x47, 0x32, 0x3b, 0x3e, 0x22, 0x82, 0x1a, 0x5b, 0xf5, 0xa6, 0xc1, 0x2a, 0x59, 0xb6, 0xf8, 0xc2,
	0x63, 0xd6, 0x9d, 0xc6, 0x05, 0x1e, 0xb8, 0x1f, 0xd5, 0x09, 0x86, 0x45, 0x96, 0x47, 0x20, 0xd8,
	0xc7, 0x24, 0xdb, 0x0b, 0x4d, 0xe0, 0x01, 0xe3, 0xa8, 0x2d, 0x67, 0xc1, 0x73, 0xbc, 0x1e, 0x51,
	0xd4, 0xb6, 0x17, 0xfb, 0x81, 0x1f, 0x45, 0xf6, 0xf6, 0x60, 0x98, 0x09, 0x80, 0x74, 0xf7, 0xd1,
	0x8b, 0x2e, 0xbe, 0x7b, 0xb8, 0xd1, 0xe1, 0xf0, 0x49, 0x38, 0xd4, 0x8a, 0xbc, 0x82, 0x98, 0xe1,
	0x8d, 0x70, 0x2f, 0xf8, 0x40, 0x74, 0x51, 0x42, 0x0e, 0x0c, 0xfa, 0xf4, 0x8f, 0x4f, 0x97, 0x98,
	0xd1, 0x80, 0xb1, 0x9a, 0x36, 0x03, 0x22, 0xfd, 0xf3, 0xfa, 0x30, 0xeb, 0x54, 0xf3, 0xcb, 0xba,
	0xdb, 0x9e, 0x61, 0x18, 0x18, 0xd1, 0x3d, 0xa4, 0x49, 0xe2, 0x05, 0xf2, 0x2b, 0x39, 0x97, 0xda,
	0x23, 0x9a, 0xf8, 0xdc, 0x77, 0xc3, 0xdb, 0xdc, 0x8b, 0x40, 0x15, 0x2c, 0xd3, 0xad, 0x54, 0x05,
	0xf9, 0x52, 0xf0, 0x28, 0x82, 0x47, 0x2f, 0xb9, 0xc1, 0x25, 0x6b, 0x2e, 0x0c, 0xf5, 0x4d, 0x08,
	0x74, 0x47, 0xb3, 0xb3, 0xbb, 0x99, 0x01, 0x9c, 0x0c, 0x25, 0x0c, 0xad, 0x17, 0x3d, 0xfa, 0x9a,
	0xd5, 0x92, 0x26, 0x75, 0xd2, 0x80, 0xf7, 0x99, 0xe9, 0x48, 0xd9, 0xda, 0x6a, 0x9d, 0x2e, 0xfe,
	0x24, 0x31, 0xa5, 0xf9, 0x78, 0xaf, 0x3a, 0x9d, 0x3e, 0x8c, 0xf5, 0x1e, 0x01, 0x28, 0x8f, 0xe3,
	0xf4, 0xb6, 0x4d, 0xf5, 0xa6, 0xb8, 0xb8, 0xb2, 0x32, 0x09, 0xec, 0x0b, 0x17, 0x7c, 0x9c, 0xec,
	0x2e, 0x62, 0xc9, 0x52, 0x15, 0x86, 0xb6, 0x68, 0xff, 0x6b, 0x2d, 0xf9, 0x18, 0x1b, 0xa8, 0x2a,
	0x2b, 0x70, 0xa9, 0xa0, 0x73, 0x4b, 0x40, 0x7e, 0xaf, 0x3a, 0x87, 0xed, 0x3a, 0xdc, 0x7b, 0xa8,
	0xa2, 0x2a, 0xfc, 0x6e, 0xf4, 0xbb, 0x7d, 0xaa, 0xe1, 0x8f, 0xcf, 0xe7, 0x50, 0xce, 0xbb, 0x7f,
	0x55, 0xf1, 0x34, 0xac, 0x86, 0x1a, 0x7d, 0x5d, 0x18, 0xb8, 0x44, 0x60, 0xf3, 0x9c, 0x2f, 0xef,
	0x5d, 0x75, 0x77, 0x61, 0x87, 0x73, 0xb2, 0x0d, 0xeb, 0xb4, 0x2b, 0x26, 0x1c, 0x91, 0x8b, 0x7e,
	0xb2, 0xe4, 0xf3, 0xc6, 0x83, 0xdb, 0xed, 0xaa, 0xb7, 0x56, 0x37, 0x8a, 0x55, 0x56, 0x5d, 0x07,
	0x38, 0xaf, 0xfa, 0x47, 0x76, 0x14, 0x42, 0x02, 0x1c, 0xc7, 0xec, 0x2e, 0x5f, 0x37, 0x41, 0xb2,
	0x02, 0x40, 0x72, 0x05, 0xee, 0xed, 0x51, 0x38, 0xbb, 0xc2, 0x6e, 0xdc, 0xce, 0xb4, 0x4d, 0x06,
	0x10, 0x4e, 0x30, 0x92, 0xc3, 0xa7, 0xb7, 0xf4, 0xd0, 0x45, 0xbc, 0x00, 0x10, 0xd7, 0xec, 0x17,
	0xd7, 0x9c, 0x1a, 0x1a, 0xf9, 0xee, 0xac, 0xdb, 0x8e, 0x0d, 0x2a, 0xc3, 0x8f, 0xf4, 0x50, 0xf3,
	0x4f, 0x12, 0x03, 0x74, 0x83, 0x65, 0x9c, 0x0d, 0xf2, 0x15, 0x1e, 0xc0, 0xbc, 0x09, 0x83, 0x67,
	0x91, 0x87, 0xe2, 0xcf, 0xc6, 0xab, 0x5b, 0x00, 0x0d, 0xd2, 0x2b, 0x02, 0x5f, 0xe1, 0x47, 0x40,
	0x5c, 0x5e, 0x48, 0x07, 0xd6, 0x94, 0x23, 0x46, 0xf7, 0xdb, 0xcc, 0xe1, 0xb4, 0x52, 0xe3, 0x47,
	0x6e, 0xea, 0x3c, 0x47, 0x19, 0x26, 0x1a, 0x0b, 0x82, 0xd4, 0x29, 0x43, 0xfc, 0xf9, 0x91, 0xc7,
	0x6f, 0x19, 0x10, 0x96, 0x00, 0x19, 0x2c, 0x06, 0x14, 0xee, 0x23, 0xfc, 0xf8, 0x9e, 0x9c, 0x88,
	0x90, 0xa8, 0x75, 0x2a, 0xf5, 0x4d, 0x91, 0x01, 0x3b, 0xf2, 0xff, 0xa2, 0x0c, 0x87, 0x8b, 0x35,
	0x87, 0x31, 0x23, 0xe9, 0x5b, 0xd3, 0x00, 0xc2, 0x7b, 0x64, 0xc4, 0x25, 0x95, 0xdd, 0x4b, 0xd2,
	0x38, 0x14, 0x9e, 0x68, 0xa6, 0x22, 0x2f, 0x78, 0xf5, 0xf7, 0x4e, 0x84, 0x18, 0x9b, 0x30, 0x48,
	0x09, 0x1b, 0xb3, 0x58, 0x05, 0x57, 0x54, 0x51, 0x77, 0x32, 0x1b, 0xcb, 0x21, 0x5f, 0x71, 0x4e,
	0xd1, 0x65, 0xd0, 0xb2, 0xd9, 0xde, 0xf2, 0x99, 0xd7, 0x42, 0xd9, 0xdf, 0xb0, 0x86, 0x6d, 0x60,
	0xe5, 0xf6, 0xd7, 0x9c, 0x0b, 0xa1, 0x4a, 0xd4, 0xa4, 0x5a, 0x4a, 0xb7, 0x08, 0x70, 0x0f, 0x0f,
	0xeb, 0x27, 0xe7, 0xef, 0xe1, 0xf9, 0xc2, 0xb3, 0xdc, 0xf6, 0xe5, 0x6f, 0x75, 0xf3, 0x76, 0x7e,
	0xea, 0x4e, 0x52, 0x63, 0xcb, 0x6a, 0xb9, 0x29, 0xa6, 0x99, 0xf9, 0xe1, 0x74, 0x50, 0x7b, 0x8d,
	0xe6, 0xde, 0xdb, 0xcc, 0xba, 0x1f, 0xb0, 0x50, 0x2c, 0x75, 0x17, 0x6d, 0xdf, 0xae, 0x3d, 0x6f,
	0xbd, 0x0d, 0xac, 0x30, 0xa2, 0xec, 0xb9, 0xa1, 0xc6, 0x6b, 0x6c, 0x91, 0x0e, 0xfa, 0x67, 0x14,
	0xfd, 0x86, 0x1e, 0x53, 0x1a, 0xd3, 0xc8, 0xd7, 0x45, 0xf3, 0x56, 0x2a, 0xb8, 0x06, 0xb5, 0x71,
	0x4c, 0x3b, 0x6a, 0xd3, 0x84, 0x86, 0xbf, 0xdb, 0x98, 0xbf, 0xa3, 0x4d, 0x60, 0xcd, 0x22, 0xf1,
	0x6a, 0x89, 0xf1, 0xa4, 0x3c, 0x85, 0x40, 0xfa, 0x65, 0x0f, 0x17, 0xcf, 0x36, 0x06, 0x43, 0x7d,
	0x31, 0x29, 0x70, 0x9b, 0x62, 0xa6, 0xed, 0xd2, 0x95, 0x99, 0x57, 0x3b, 0x15, 0xb3, 0x26, 0x35,
	0x18, 0x04, 0x65, 0x81, 0x69, 0x3a, 0xfa, 0xeb, 0x7b, 0x4f, 0xc7, 0x12, 0x69, 0x10, 0x0d, 0x1e,
	0xce, 0xdc, 0x9a, 0x78, 0x7b, 0xbe, 0xd3, 0xee, 0xd3, 0xec, 0x80, 0xb3, 0x70, 0xac, 0x56, 0x11,
	0x49, 0xb0, 0x08, 0x96, 0xc4, 0x8f, 0x8b, 0xea, 0x0f, 0xf6, 0xd8, 0x88, 0x21, 0x76, 0xcd, 0x1c,
	0x63, 0x02, 0xd9, 0x88, 0x9f, 0xdc, 0x49, 0x68, 0x39, 0x16, 0x4f, 0x6e, 0x76, 0x8b, 0xad, 0x65,
	0xa5, 0x42, 0x6e, 0x2b, 0x7f, 0xad, 0x08, 0x33, 0xbd, 0x27, 0xfe, 0xbc, 0x1a, 0xdc, 0x53, 0x36,
	0xe8, 0x31, 0xd9, 0x42, 0x2e, 0x6f, 0xe1, 0xad, 0xe5, 0xf5, 0xa1, 0x0d, 0x1f, 0x80, 0x13, 0xd4,
	0xd3, 0x60, 0x98, 0x41, 0x9f, 0x5f, 0xc0, 0xbe, 0xe9, 0xee, 0xc0, 0x6d, 0x8b, 0x7f, 0x99, 0x7c,
	0x2b, 0xe9, 0x0c, 0x75, 0xbc, 0xee, 0x57, 0xe1, 0x3b, 0x49, 0xc9, 0x9f, 0x9f, 0x96, 0xfb, 0x47,
	0x55, 0xd8, 0x5c, 0x3f, 0x9a, 0x6e, 0x1e, 0xba, 0x69, 0x44, 0x92, 0xd2, 0x20, 0xb6, 0xcc, 0xdc,
	0x76, 0x5a, 0x24, 0xab, 0x71, 0x19, 0xad, 0x3d, 0x17, 0xf6, 0xa1, 0xea, 0x58, 0x35, 0x56, 0xf8,
	0x8c, 0x6b, 0xb2, 0x1f, 0xd0, 0xf6, 0x8b, 0x75, 0x8f, 0x95, 0xd1, 0x16, 0x54, 0x12, 0x7a, 0x86,
	0xd6, 0x8a, 0xf2, 0x65, 0x6f, 0x7a, 0x70, 0x89, 0x65, 0x0f, 0x2f, 0x1b, 0x02, 0x78, 0x90, 0x55,
	0xc8, 0xa3, 0x0d, 0xce, 0x3b, 0xc8, 0x8d, 0x51, 0x09, 0xeb, 0xb8, 0xfa, 0xf7, 0xc9, 0x1b, 0x2b,
	0xd6, 0xbe, 0x42, 0xaf, 0x34, 0x63, 0x75, 0x3a, 0xa2, 0x5f, 0x66, 0x50, 0x63, 0xea, 0x8a, 0x78,
	0xd4, 0xbc, 0x7e, 0x61, 0xe7, 0x62, 0x9d, 0x6c, 0xcc, 0x8c, 0x79, 0x3a, 0xbe, 0x59, 0xa8, 0xb1,
	0x69, 0x73, 0x03, 0x3f, 0xe9, 0x9b, 0xcc, 0xd0, 0x1e, 0x70, 0x55, 0x3d, 0x76, 0xfe, 0xc9, 0xe0,
	0xe8, 0x25, 0xa6, 0xd6, 0x22, 0x1a, 0x28, 0x57, 0xc0, 0xed, 0xba, 0xcd, 0x80, 0x28, 0xf8, 0xfc,
	0x52, 0xd1, 0xe3, 0x18, 0xf6, 0xec, 0xcb, 0x01, 0x10, 0x9f, 0x68, 0x9a, 0xda, 0xf4, 0x7e, 0xe3,
	0xbb, 0x76, 0x21, 0x9e, 0x02, 0x1b, 0x4e, 0xeb, 0x4c, 0xa8, 0x6d, 0xe1, 0x3a, 0xbc, 0xc4, 0xaa,
	0xbe, 0x3f, 0x2a, 0xcd, 0x27, 0xfe, 0x9f, 0x42, 0x58, 0x94, 0x0f, 0x1e, 0xf3, 0x46, 0x2c, 0x98,
	0x46, 0x41, 0x68, 0x1e, 0x4f, 0xaa, 0x02, 0xae, 0x86, 0xa8, 0xe6, 0x36, 0xfd, 0x1e, 0xe3, 0x47,
	0x49, 0x9e, 0xbf, 0x47, 0x7b, 0x75, 0xf6, 0xe1, 0x67, 0xd7, 0x46, 0x32, 0x97, 0xfa, 0xb3, 0xf2,
	0x7b, 0xc0, 0xfb, 0x92, 0x4f, 0xdc, 0xc5, 0x05, 0x70, 0xad, 0xc3, 0x52, 0x1f, 0x31, 0x9c, 0xd5,
	0xb3, 0xc8, 0x15, 0x9b, 0xb4, 0x74, 0xcf, 0x30, 0xd6, 0xbf, 0x6e, 0x68, 0x87, 0x49, 0x2b, 0xad,
	0x7c, 0xa7, 0x41, 0xfc, 0x88, 0x79, 0x41, 0xd4, 0x6e, 0x60, 0x64, 0x2d, 0x8e, 0xd3, 0xa5, 0xf8,
	0xf3, 0xe5, 0x64, 0x99, 0xec, 0x4c, 0x7b, 0xc2, 0x24, 0xee, 0x4c, 0x8b, 0xf2, 0x03, 0x5e, 0x5a,
	0xea, 0xdf, 0x3a, 0x09, 0xf2, 0xb3, 0x15, 0xca, 0xfa, 0x68, 0xc0, 0xa9, 0xa3, 0x1c, 0xdf, 0x5d,
	0x00, 0x52, 0x29, 0xdf, 0x72, 0x2d, 0xf1, 0x16, 0x35, 0x58, 0xfe, 0x82, 0x52, 0x80, 0x2d, 0xbf,
	0x1c, 0x98, 0xf9, 0x9b, 0x10, 0xde, 0xfe, 0x76, 0x41, 0x71, 0xfa, 0x9b, 0x37, 0x51, 0xdd, 0xec,
	0x4a, 0x19, 0x27, 0x65, 0xbb, 0x49, 0x34, 0xc2, 0xa8, 0xf9, 0xfd, 0x91, 0xaa, 0x77, 0x22, 0xec,
	0x81, 0xe2, 0xa8, 0x4c, 0x59, 0xf8, 0xb9, 0xcf, 0x77, 0xd0, 0x06, 0x9c, 0x41, 0xed, 0xf2, 0x60,
	0x34, 0xc6, 0xda, 0xdb, 0x96, 0xa6, 0xa8, 0x01, 0x8d, 0xc3, 0xb0, 0x7a, 0xc6, 0x0d, 0x0c, 0xa5,
	0xa9, 0x8a, 0xf0, 0x7c, 0x50, 0x4c, 0x65, 0xe0, 0xd4, 0xf9, 0xf8, 0x7e, 0xfe, 0x4c, 0xe3, 0x4f,
	0x29, 0xfb, 0xfc, 0x90, 0x31, 0xda, 0xd4, 0x19, 0x8b, 0x39, 0x6e, 0x2d, 0x4a, 0x13, 0x88, 0x29,
	0xc6, 0x65, 0xf3, 0x37, 0xf1, 0x2b, 0x40, 0xfb, 0xde, 0x06, 0x4a, 0xe2, 0xa1, 0xe0, 0x62, 0x7a,
	0xdf, 0xf6, 0xe1, 0x53, 0x20, 0x8b, 0x15, 0x6b, 0xc9, 0xc9, 0xf7, 0x51, 0x3c, 0xda, 0x5d, 0x54,
	0xd6, 0xbc, 0x2b, 0xeb, 0xdf, 0xf8, 0x66, 0xe1, 0x44, 0xe1, 0x22, 0x3b, 0x6a, 0x33, 0xfb, 0x99,
	0xc2, 0xb3, 0xf1, 0xd3, 0x24, 0x0c, 0xb7, 0x00
};

static unsigned char ps_yuv2rgb[] =
{
	0x44, 0x05, 0x00, 0x00, 0x08, 0x94, 0x60, 0x37, 0x31, 0x47, 0x4d, 0xc5, 0x14, 0xc6, 0x6d, 0xac,
	0xfe, 0xab, 0x89, 0xe9, 0x70, 0x2a, 0x96, 0x8d, 0x9f, 0xb0, 0xbe, 0xb0, 0x93, 0xf3, 0xc1, 0x4b,
	0x7a, 0xd9, 0x77, 0xd4, 0x45, 0x58, 0x11, 0x37, 0x92, 0x2b, 0xaa, 0xe0, 0x74, 0xa5, 0xef, 0x6d,
	0x29, 0xf0, 0x3d, 0xd8, 0xf2, 0xbe, 0xd2, 0xe6, 0xfe, 0xc6, 0x0b, 0xc0, 0x9b, 0xda, 0x2b, 0x6c,
	0x25, 0xf1, 0xf6, 0xfb, 0xa1, 0x48, 0xe2, 0x4d, 0xa4, 0x47, 0xe7, 0xc2, 0xc9, 0xe4, 0x3b, 0xdc,
	0x12, 0x13, 0xe2, 0xaf, 0xa8, 0x37, 0x98, 0x5b, 0x5a, 0x8b, 0xb0, 0xa7, 0x31, 0xc2, 0x30, 0x8b,
	0xd2, 0x49, 0x1f, 0x9f, 0x07, 0x18, 0xff, 0x40, 0xc0, 0xab, 0x86, 0xa1, 0xc0, 0xd0, 0xf4, 0xf8,
	0xda, 0xc8, 0x6e, 0x91, 0x45, 0xa9, 0x93, 0xe6, 0x0b, 0xdd, 0x8e, 0x86, 0x9c, 0x1c, 0xc6, 0x11,
	0xbf, 0xdb, 0x49, 0x49, 0x00, 0x8b, 0xac, 0xa0, 0x84, 0x4c, 0xa6, 0x00, 0x53, 0x4d, 0xd1, 0x44,
	0x7b, 0x9e, 0xb4, 0x62, 0x18, 0x99, 0xf9, 0x6d, 0x5a, 0xba, 0x7a, 0xa3, 0x1c, 0x23, 0xda, 0x68,
	0x34, 0x5c, 0x0e, 0x80, 0x27, 0x72, 0x73, 0x3d, 0x85, 0x56, 0x35, 0x98, 0x34, 0x46, 0xd1, 0x5c,
	0x14, 0x75, 0x01, 0xe4, 0xa9, 0x37, 0x8a, 0x3d, 0x5d, 0x21, 0xfe, 0x94, 0x85, 0x2f, 0xdc, 0x98,
	0x38, 0xc2, 0x8a, 0x3b, 0xeb, 0x91, 0xb6, 0x25, 0x8f, 0x9b, 0xc6, 0xd1, 0x78, 0x2b, 0x1a, 0x33,
	0x62, 0x56, 0x9e, 0x7f, 0xf0, 0xe5, 0x57, 0x9b, 0xcf, 0x4e, 0x94, 0xc3, 0x76, 0x4a, 0xf1, 0x02,
	0xf9, 0x01, 0xa5, 0xe1, 0xe4, 0xc2, 0xaa, 0xc8, 0x78, 0x3e, 0x37, 0xe5, 0xf8, 0x09, 0x52, 0x4b,
	0x2d, 0x98, 0x2e, 0x86, 0x32, 0x16, 0x1f, 0x95, 0x0a, 0xce, 0x09, 0xe0, 0x07, 0x21, 0x60, 0x5c,
	0xd4, 0xce, 0xc6, 0xee, 0x6a, 0x3c, 0x2b, 0x22, 0x91, 0x39, 0xa8, 0xbc, 0x15, 0xd2, 0x2a, 0x2a,
	0x08, 0xa7, 0x8f, 0x46, 0xda, 0x14, 0x60, 0x92, 0xc4, 0xa7, 0x53, 0x67, 0xe1, 0x05, 0x1c, 0xaf,
	0x06, 0xc6, 0xf0, 0x7a, 0x76, 0xd3, 0x04, 0x72, 0xf9, 0xa8, 0x1c, 0xbb, 0xc1, 0x46, 0x1b, 0x8d,
	0xc0, 0x89, 0xca, 0x69, 0x2c, 0x5c, 0x40, 0x32, 0xb7, 0xe7, 0x50, 0x05, 0x48, 0x5a, 0x86, 0xdb,
	0x92, 0x5e, 0x28, 0xe0, 0x67, 0xf8, 0x97, 0x4c, 0x3c, 0x02, 0x01, 0x51, 0x58, 0x33, 0xac, 0x03,
	0x8d, 0xa6, 0x34, 0x6f, 0x49, 0x51, 0x9a, 0x46, 0x6f, 0xbd, 0x87, 0x07, 0xb1, 0xa3, 0x88, 0x11,
	0xea, 0x30, 0x61, 0x73, 0x56, 0x0d, 0xba, 0xb9, 0x97, 0x10, 0xc9, 0x85, 0x05, 0x05, 0x6a, 0x1f,
	0x66, 0x45, 0xf3, 0xe3, 0x77, 0x2b, 0xd9, 0x70, 0x54, 0x0a, 0x4f, 0xb8, 0x48, 0x7b, 0x68, 0x14,
	0xed, 0x2a, 0x1c, 0x13, 0xd4, 0x4e, 0x82, 0xef, 0x38, 0xeb, 0x95, 0x2b, 0x55, 0x81, 0x64, 0x17,
	0x2d, 0x15, 0x05, 0xb7, 0xdb, 0x09, 0xd5, 0x94, 0xd4, 0xaa, 0xda, 0x8d, 0x26, 0xd1, 0xc3, 0xc0,
	0xfc, 0x6c, 0x1f, 0x9e, 0xb7, 0xe2, 0x99, 0xa3, 0xab, 0xff, 0xf2, 0xe8, 0x06, 0x0e, 0x18, 0xd3,
	0x3b, 0x51, 0xb0, 0x8f, 0xea, 0xc9, 0xfc, 0x81, 0x9a, 0xdf, 0xb2, 0xd3, 0x55, 0x23, 0x82, 0xca,
	0x22, 0xc1, 0x19, 0x08, 0xe8, 0x06, 0xf6, 0x46, 0x8c, 0xed, 0xca, 0xec, 0x68, 0x4e, 0x82, 0x74,
	0x13, 0x84, 0xf5, 0xb7, 0xc2, 0x7a, 0xf9, 0x48, 0x50, 0xea, 0x2e, 0xbc, 0x67, 0x1b, 0x31, 0x80,
	0xa0, 0x33, 0xfd, 0x52, 0x4b, 0xb0, 0x88, 0xa7, 0xe0, 0xc2, 0x6d, 0x7e, 0x21, 0x51, 0x8b, 0xe4,
	0x4f, 0xcd, 0x9b, 0x86, 0x9f, 0x26, 0x24, 0x30, 0x7b, 0xb7, 0x9d, 0x1f, 0x3a, 0x05, 0x36, 0x14,
	0xa3, 0x96, 0x2d, 0xc2, 0xcf, 0xf4, 0x5b, 0xd5, 0x1c, 0xa1, 0xb6, 0xb9, 0x51, 0x64, 0x6e, 0x0c,
	0x4b, 0xe4, 0x77, 0xb6, 0xc6, 0xc3, 0x4d, 0x21, 0x1e, 0x6f, 0x5d, 0x31, 0x1b, 0xef, 0xa6, 0x33,
	0xf1, 0xa4, 0xcf, 0xed, 0x08, 0xbd, 0x7b, 0x41, 0xef, 0x69, 0xf7, 0x2c, 0xb0, 0xce, 0x17, 0x8a,
	0x9b, 0x0a, 0x83, 0xb7, 0xc6, 0xf4, 0xa9, 0x6f, 0x38, 0x9e, 0x6d, 0x99, 0x14, 0x40, 0xf0, 0x55,
	0xc8, 0x5e, 0xd9, 0x52, 0x67, 0x0d, 0x4e, 0x09, 0x8d, 0x65, 0x75, 0xb2, 0xf4, 0xbe, 0x49, 0x55,
	0xca, 0x70, 0xc9, 0xaf, 0x43, 0xc3, 0x2a, 0xbf, 0xbf, 0xef, 0xd3, 0xf6, 0x0c, 0x4e, 0x93, 0xb8,
	0x49, 0x6f, 0xc1, 0x0f, 0xfb, 0x7a, 0x1c, 0x6d, 0xb1, 0x1c, 0x94, 0x16, 0x25, 0x70, 0x95, 0x01,
	0x14, 0x18, 0x13, 0xdc, 0x19, 0x9d, 0xcc, 0xd6, 0x8e, 0xf3, 0x9c, 0x4c, 0x91, 0xbb, 0xc7, 0x2a,
	0x56, 0x85, 0xeb, 0x2a, 0xe1, 0x57, 0xd2, 0x07, 0x26, 0xbc, 0x2a, 0x52, 0x66, 0x9c, 0x34, 0xe0,
	0x4a, 0xbf, 0xb4, 0xc9, 0x3d, 0x03, 0x28, 0x23, 0x28, 0x1b, 0x86, 0x46, 0xe0, 0xac, 0xc2, 0x03,
	0x9e, 0xf0, 0x17, 0xe3, 0x97, 0xb6, 0x71, 0x67, 0x38, 0xdf, 0xf6, 0xff, 0x74, 0x97, 0xc7, 0x01,
	0x65, 0x10, 0xbe, 0x0d, 0xe9, 0x95, 0x8a, 0xd1, 0x39, 0x8a, 0xed, 0x1a, 0xf0, 0xec, 0xde, 0xa3,
	0xe1, 0xf3, 0xf1, 0x45, 0xaa, 0x3c, 0x28, 0x66, 0x5b, 0x00, 0x5b, 0x6f, 0xfb, 0x68, 0xb5, 0xc6,
	0xe1, 0xef, 0xa1, 0xca, 0xae, 0x80, 0x9a, 0xda, 0x43, 0x40, 0xc4, 0x70, 0x25, 0x26, 0xb5, 0x61,
	0xc8, 0x0d, 0x15, 0xf3, 0x5f, 0xe3, 0xc6, 0x96, 0xa2, 0xe6, 0xbb, 0xe2, 0x36, 0x53, 0xdd, 0x84,
	0x9a, 0x43, 0xbf, 0x8e, 0xfd, 0xb1, 0x5b, 0x4f, 0x32, 0xc5, 0x52, 0x36, 0xdf, 0x49, 0x2f, 0x5d,
	0x03, 0x75, 0xa1, 0x8c, 0xb9, 0x3d, 0x17, 0x39, 0xfd, 0x8a, 0x4c, 0x95, 0xc8, 0x6d, 0xb7, 0xa9,
	0x8d, 0x41, 0xfb, 0xa7, 0x39, 0xd3, 0xe3, 0x1b, 0xd2, 0x93, 0x7b, 0xc2, 0x67, 0xbd, 0xa1, 0x80,
	0x78, 0x6c, 0x50, 0xe7, 0x41, 0xc9, 0x44, 0x7b, 0x7e, 0x77, 0xad, 0xa6, 0xbd, 0x1b, 0x25, 0x20,
	0x80, 0x11, 0x14, 0xda, 0x9a, 0xfd, 0xfb, 0x04, 0xcb, 0x58, 0xb7, 0x36, 0x3d, 0x8d, 0x07, 0x98,
	0x90, 0xeb, 0xbd, 0xb8, 0x60, 0x8a, 0xc6, 0x01, 0xab, 0x52, 0x71, 0x1f, 0x33, 0x0a, 0x1d, 0x20,
	0x07, 0x67, 0x00, 0x42, 0x86, 0x5d, 0x65, 0x09, 0x5f, 0x0a, 0xa2, 0x78, 0x9c, 0xff, 0xf0, 0xc1,
	0x0b, 0xae, 0x68, 0xac, 0xbc, 0xab, 0x9f, 0xca, 0xda, 0xaa, 0xe2, 0x8a, 0xa7, 0x24, 0xb9, 0xbd,
	0x4a, 0xf4, 0xa1, 0x8a, 0x92, 0xc0, 0x07, 0x8b, 0x2e, 0xca, 0x73, 0x22, 0x61, 0x41, 0xe3, 0x84,
	0xe3, 0x4f, 0x3b, 0x7e, 0xbc, 0x7a, 0x8a, 0xdf, 0x3f, 0x4d, 0xab, 0x14, 0x14, 0xa3, 0x01, 0x3d,
	0xdc, 0x62, 0xe4, 0x36, 0xef, 0xe0, 0x9c, 0x3f, 0x43, 0xd3, 0x60, 0x19, 0xa2, 0x16, 0x9a, 0x8f,
	0xeb, 0xba, 0x32, 0xf1, 0x4d, 0x5f, 0x7f, 0x54, 0x00
};

HRESULT VS_Direct3DRender::InitResizers()
{
	HRESULT hr;
	int i, j;

	do {
		if (!m_pPSResizer[0])
			break;
		if (!m_pPSResizer[1])
			break;
		if (!m_pPSYUV2RGB)
			break;
		if (!m_pScreenSizeTemporaryTexture)
			break;
		return S_OK;
	} while (0);

	m_pScreenSizeTemporaryTexture = NULL;

	m_pPSResizer[0] = NULL;
	m_pPSResizer[1] = NULL;
	m_pPSYUV2RGB = NULL;

	if(m_caps.PixelShaderVersion < D3DPS_VERSION(2, 0)) {
		DTRACE(VSTM_VRND, "incorrect shader version %d.%d", D3DSHADER_VERSION_MAJOR(m_caps.PixelShaderVersion), D3DSHADER_VERSION_MINOR(m_caps.PixelShaderVersion));
		sprintf(m_cError, "incorrect shader version %ld.%ld\n", D3DSHADER_VERSION_MAJOR(m_caps.PixelShaderVersion), D3DSHADER_VERSION_MINOR(m_caps.PixelShaderVersion));
		return E_FAIL;
	}

	LPCSTR pProfile = m_caps.PixelShaderVersion >= D3DPS_VERSION(3, 0) ? "ps_3_0" : "ps_2_0";

	VS_Container cnt;
	char name[4][128] = {"resampler", "yuv2rgb", "", ""};
	char *pBuffShader[4] = {0};
	unsigned long nBuffLen[4] = {0};
	size_t sz=0;

	unsigned char *pResampler = ps_resampler_bicubic;
	unsigned long sizeBuff = sizeof(ps_resampler_bicubic);
	char nameResampler[2][128];

#ifdef D3D_SHADERS_FROM_FILE
	char fileResampler[128];
	sprintf(fileResampler, "resampler_%s.psh", "bicubic");
#endif

#if 0
	char *pb = 0;
	unsigned char *pbcnt = 0;
	unsigned long size = 0;
	fpos_t pos0, pos1;
	const char name_[] = "yuv2rgb";
	FILE *f = fopen("dec.psh", "rb");

	fgetpos(f, &pos0);
	fseek(f, 0, SEEK_END);
	fgetpos(f, &pos1);
	unsigned long len = (unsigned long)(pos1 - pos0);
	fseek(f, 0, SEEK_SET);
	pb = (char*)malloc(len);
	fread(pb, len, 1, f);
	fclose(f);

	cnt.AddValue(name_, pb, len);
	cnt.SerializeAlloc((void*&)pbcnt, size);
	free(pb);
	len = 0;
	f = fopen("bin.psh", "wb");
	for (i = 0; i < size; i++) {
		if (i % 16 == 0) fprintf(f, "\n");
		fprintf(f, "0x%2.2x, ", pbcnt[i]);
	}
	fclose(f);
#else

	sprintf(nameResampler[0], "vp_resampler_%s_x", "bicubic");
	sprintf(nameResampler[1], "vp_resampler_%s_y", "bicubic");

	if (m_ResizeMode == RM_BILINEAR) {

	} else if (m_ResizeMode == RM_LANCZOS) {
		pResampler = ps_resampler_lanczos;
		sizeBuff = sizeof(ps_resampler_lanczos);
		sprintf(nameResampler[0], "vp_resampler_%s_x", "lanczos");
		sprintf(nameResampler[1], "vp_resampler_%s_y", "lanczos");

#ifdef D3D_SHADERS_FROM_FILE
		sprintf(fileResampler, "resampler_%s.psh", "lanczos");
#endif

	}

#ifndef D3D_SHADERS_FROM_FILE
	if (!cnt.Deserialize(pResampler, sizeBuff)) {
		DTRACE(VSTM_VRND, "failed deserialize resample shader");
		sprintf(m_cError, "failed deserialize resample shader");
		return E_FAIL;
	}
	if (!cnt.GetValue(name[0], (void*)(pBuffShader[0]), sz)) {
		pBuffShader[0] = (char*)malloc(sz);
		if (!cnt.GetValue(name[0], (void*)(pBuffShader[0]), sz)) {
			DTRACE(VSTM_VRND, "failed load resample shader");
			sprintf(m_cError, "failed load resample shader");
			return E_FAIL;
		}
	}
	nBuffLen[0] = sz;
	sz = 0;
	if (!cnt.Deserialize(ps_yuv2rgb, sizeof(ps_yuv2rgb))) {
		DTRACE(VSTM_VRND, "failed deserialize yuv2rgb shader");
		sprintf(m_cError, "failed deserialize yuv2rgb shader");
		return E_FAIL;
	}
	if (!cnt.GetValue(name[1], (void*)(pBuffShader[1]), sz)) {
		pBuffShader[1] = (char*)malloc(sz);
		if (!cnt.GetValue(name[1], (void*)(pBuffShader[1]), sz)) {
			DTRACE(VSTM_VRND, "failed load yuv2rgb shader");
			sprintf(m_cError, "failed load yuv2rgb shader");
			return E_FAIL;
		}
	}
	nBuffLen[1] = sz;
#endif

#endif

	LPCSTR pEntries[] = {nameResampler[0], nameResampler[1],
						 "vp_conversion_yuv2rgb"};

	int iCount = sizeof(pEntries) / sizeof(pEntries[0]);

	for (i = 0; i < iCount; i++) {
		CComPtr<ID3DXBuffer> pShader, pErrorMsgs;

		if (i < 2) { // resamplers

#ifndef D3D_SHADERS_FROM_FILE
			hr = g_pD3DXCompileShader(pBuffShader[0], nBuffLen[0], NULL, NULL, pEntries[i], pProfile, 0, &pShader, &pErrorMsgs, NULL);
#else
			hr = g_pD3DXCompileShader(fileResampler, NULL, NULL, pEntries[i], pProfile, 0, &pShader, &pErrorMsgs, NULL);
#endif

			if (SUCCEEDED(hr)) {
				hr = m_pD3DDev->CreatePixelShader((DWORD*)pShader->GetBufferPointer(), &m_pPSResizer[i%2]);
			}
		} else {

#ifndef D3D_SHADERS_FROM_FILE
			hr = g_pD3DXCompileShader(pBuffShader[i-1], nBuffLen[i-1], NULL, NULL, pEntries[i], pProfile, 0, &pShader, &pErrorMsgs, NULL);
#else
			if (strcmp(pEntries[i], "vp_conversion_yuv2rgb") == 0) {
				hr = g_pD3DXCompileShader("yuv2rgb.psh", NULL, NULL, pEntries[i], pProfile, 0, &pShader, &pErrorMsgs, NULL);
			}
#endif

			if (SUCCEEDED(hr)) {
				if (strcmp(pEntries[i], "vp_conversion_yuv2rgb") == 0) {
					hr = m_pD3DDev->CreatePixelShader((DWORD*)pShader->GetBufferPointer(), &m_pPSYUV2RGB);
				}
			}
		}
		if (FAILED(hr)) {

#ifdef D3D_SHADERS_FROM_FILE
			FILE *Err = fopen("sh_err.txt", "w");
			if (pErrorMsgs) {
				fwrite(pErrorMsgs->GetBufferPointer(), pErrorMsgs->GetBufferSize(), 1, Err);
			} else {
				char ch[128] = {};
				sprintf(ch, "invalid file name %s", fileResampler);
				fwrite(ch, sizeof(ch), 1, Err);
			}
			fclose(Err);
#endif

			DTRACE(VSTM_VRND, "failed create shader %d", i);
			sprintf(m_cError, "failed create shader %d", i);
			for (j = 0; j < sizeof(nBuffLen) / sizeof(unsigned long); j++) {
				if (pBuffShader[j]) free(pBuffShader[j]);
			}
			return hr;
		}
	}

	for (j = 0; j < sizeof(pBuffShader) / sizeof(pBuffShader[0]); j++) {
		if (pBuffShader[j]) free(pBuffShader[j]);
	}

	hr = m_pD3DDev->CreateTexture(std::min<UINT>(m_ScreenSize.cx, m_caps.MaxTextureWidth),
								  std::min<UINT>(std::max<UINT>(m_ScreenSize.cy, m_biFmtIn.biHeight), m_caps.MaxTextureHeight),
								  1,
								  D3DUSAGE_RENDERTARGET,
								  m_BackbufferType,
								  D3DPOOL_DEFAULT,
								  &m_pScreenSizeTemporaryTexture,
								  NULL);

	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create temp texture");
		sprintf(m_cError, "failed create temp texture");
		m_pScreenSizeTemporaryTexture = NULL;
	}

	return S_OK;
}

#define D3D_BCKGR_COLOR		RGB(0x00, 0x00, 0x00)
#define D3D_INV_BCKGR_COLOR RGB(0x00, 0x00, 0x00)
#define D3D_TEXT_COLOR		RGB(0xff, 0xff, 0xff)

int VS_Direct3DRender::CreateTextureName(int w, int h)
{
	if (m_DisplayName.name.empty() || w <= 0 || h <= 0) {
		SetRectEmpty(&m_DisplayName.rName);
		return -1;
	}

	int ow, oh;
	ow = m_DisplayName.width;
	oh = m_DisplayName.height;
	m_DisplayName.width = w;
	m_DisplayName.height = h / 16;
	if (m_DisplayName.height < 13) m_DisplayName.height = 13;
	int htxt = m_DisplayName.height;
	m_DisplayName.height = (m_DisplayName.height + 1)&~1;

	if (ow != m_DisplayName.width || oh != m_DisplayName.height || m_pNameTexture == NULL || m_DisplayName.update) {
		SetRectEmpty(&m_DisplayName.rName);

		SIZE sizeText;
		HDC hDC = GetDC(NULL);
		HDC myDc = CreateCompatibleDC(hDC);
		HBITMAP bmap = CreateCompatibleBitmap(hDC, m_DisplayName.width, m_DisplayName.height);
		SelectObject(myDc, bmap);

		HFONT hFont = CreateFontW(htxt, 0, 0, 0, FW_LIGHT, 0, 0, 0,
								  DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
								  FF_SWISS|VARIABLE_PITCH, L"Tahoma\0");
		if (hFont) {
			SelectObject(myDc, hFont);
			GetTextExtentPoint32W(myDc, m_DisplayName.name.data(), m_DisplayName.name.length(), &sizeText);

			RECT rect;
			SetRect(&rect, 0, 0, m_DisplayName.width, m_DisplayName.height);
			SetBkColor(myDc, D3D_BCKGR_COLOR);
			HBRUSH hbr = CreateSolidBrush(D3D_BCKGR_COLOR);
			FillRect(myDc, &rect, hbr);
			SetTextColor(myDc, D3D_TEXT_COLOR);
			DrawTextW(myDc, m_DisplayName.name.data(), m_DisplayName.name.length(), &rect, DT_CENTER | DT_END_ELLIPSIS | DT_NOPREFIX);

			auto text_data = std::make_unique<unsigned char[]>(m_DisplayName.width * m_DisplayName.height * 4);

			BITMAPINFO bmi;
			memset(&bmi.bmiHeader, 0, sizeof(BITMAPINFOHEADER));
			bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
			bmi.bmiHeader.biBitCount = 32;
			bmi.bmiHeader.biHeight = m_DisplayName.height;
			bmi.bmiHeader.biPlanes = 1;
			bmi.bmiHeader.biWidth = m_DisplayName.width;
			bmi.bmiHeader.biSizeImage = m_DisplayName.width * m_DisplayName.height * 4;

			GetDIBits(myDc, bmap, 0, m_DisplayName.height, text_data.get(), &bmi, DIB_RGB_COLORS);

			HRESULT hr;
			m_pNameTexture = NULL;
			hr = m_pD3DDev->CreateTexture(m_DisplayName.width, m_DisplayName.height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &m_pNameTexture, NULL);

			if ( SUCCEEDED(hr) ) {
				D3DLOCKED_RECT lrect;
				hr = m_pNameTexture->LockRect(0, &lrect, &rect, NULL);
				if ( SUCCEEDED(hr) ) {
					CopyRect(&m_DisplayName.rName, &rect);
					int i, j;
					unsigned int *pTexture = (unsigned int*)(lrect.pBits);
					unsigned int *pSrc = reinterpret_cast<unsigned int*>(text_data.get()) + m_DisplayName.width * (m_DisplayName.height - 1);
					for (i = 0; i < m_DisplayName.height; i++) {
						for (j = 0; j < m_DisplayName.width; j++) {
							if (pSrc[j] == D3D_INV_BCKGR_COLOR) {
								pTexture[j] = pSrc[j] | 0x80000000;
							} else {
								pTexture[j] = pSrc[j] | 0xff000000;
							}
						}
						pTexture += lrect.Pitch / 4;
						pSrc -= m_DisplayName.width;
					}
					m_pNameTexture->UnlockRect(0);
				}
			}

			DeleteObject(hbr);
			DeleteObject(hFont);
		}

		DeleteObject(bmap);
		DeleteDC(myDc);
		ReleaseDC(NULL, hDC);

		m_DisplayName.update = false;
	}

	return 0;
}

/////// Direct3D10

struct vertex
{
	D3DXVECTOR3 pos;
	D3DXVECTOR4 color;
	D3DXVECTOR2 texCoord;

	vertex(D3DXVECTOR3 p, D3DXVECTOR4 c)
	{
		pos = p;
		color = c;
	}

	vertex(D3DXVECTOR3 p, D3DXVECTOR4 c, D3DXVECTOR2 tex)
	{
		pos = p;
		color = c;
		texCoord = tex;
	}
};

VS_Direct3D10Render::VS_Direct3D10Render(CVSInterface* pParentInterface, HWND hwnd) : CVideoRenderBase(pParentInterface)
{
	m_cError[0] = 0;
	m_repairTime = 0;
	m_bCanFS = 1;
	m_pDeviceD3D10 = 0;
	m_pDXGIDevice = 0;
	m_pDXGIAdapter = 0;
	m_pDXGIFactory = 0;
	m_pSwapChain = 0;
	for (int i = 0; i < NUM_STAGESNAME_NAME; i++) {
		m_pRenderTarget[i] = 0;
		m_pShaderResView[i] = 0;
		m_pTexture[i] = 0;
	}
	m_pVertexBuffer = 0;
	m_pVertexLayout = 0;
	m_pEffect = 0;
	m_pBlendState = 0;
	m_pRS = 0;
	m_bDrawLogo = false;
	m_IsValid = false;
	m_rDstVid.bottom = m_rDstVid.right = m_rDstVid.top = m_rDstVid.left = 320;
	m_bUseD3D = TestD3DCaps(hwnd);
	m_numVertices = 4;
	m_TypeRender = VR_DIRECT_3D10;
}

VS_Direct3D10Render::~VS_Direct3D10Render()
{
	ReleaseDevice();
}

/**
****************************************************************************
 * \brief Fill info about video driver
 *
 * \param driver				- name of driver dll;
 * \param desc					- driver desc;
 *
 * \date    14-01-2011
 ******************************************************************************/
bool VS_Direct3D10Render::FillDeviceInfo(char* driver, char* desc)
{
	char tmp[256], name[256];
	wchar_t device_desc[256];
	DWORD DeviceIndex = 0;
	HDEVINFO handle = SetupDiGetClassDevs(&GUID_DEVCLASS_DISPLAY, NULL, NULL, DIGCF_PRESENT);
	if( SUCCEEDED(handle) ) {
		BOOL ret = FALSE;
		strcat(driver, "\n");
		while (true) {
			device_desc[0] = 0;
			SP_DEVINFO_DATA devInfo;
			ZeroMemory(&devInfo, sizeof(SP_DEVINFO_DATA));
			devInfo.cbSize = sizeof(SP_DEVINFO_DATA);
			ret = SetupDiEnumDeviceInfo(handle, DeviceIndex, &devInfo);
			if (ret == TRUE) {
				HKEY hkey = SetupDiOpenDevRegKey(handle, &devInfo, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_QUERY_VALUE);
				if (hkey != INVALID_HANDLE_VALUE) {

					char par[4][2][256] = {
						{ "Description:  ", "DriverDesc" },
						{ "Version:      ", "DriverVersion" },
						{ "Date:	      ", "DriverDate" },
						{ "Installed:    ", "InstalledDisplayDrivers" },
					};

					sprintf(tmp, "===== Device #%ld =====\n", DeviceIndex);
					strcat(driver, tmp);

					for (int i = 0; i < 4; i++) {
						DWORD sizeTmp = sizeof(name);
						int noError = RegQueryValueEx(hkey, TEXT(par[i][1]), 0, 0, (LPBYTE)name, &sizeTmp);
						if (noError == ERROR_SUCCESS) {
							if (i == 0) {
								mbstowcs(device_desc, name, 256);
							}
							sprintf(tmp, "%s %s\n", par[i][0], name);
							strcat(driver, tmp);
						}
					}

					RegCloseKey(hkey);

					if (m_pDXGIFactory) {
						IDXGIAdapter *pAdapter = 0;
						for (UINT i = 0;
							 m_pDXGIFactory->EnumAdapters(i, &pAdapter) != DXGI_ERROR_NOT_FOUND;
							 ++i)
						{
							DXGI_ADAPTER_DESC adaptDesc;
							HRESULT hr = pAdapter->GetDesc(&adaptDesc);
							if ( SUCCEEDED(hr) ) {
								if (wcscmp(device_desc, adaptDesc.Description) == 0) {
									strcat(driver, "\n[Property]\n");
									sprintf(tmp, "video memory:  %ld (MB)\n",
												 adaptDesc.DedicatedVideoMemory / 1024 / 1024);
									strcat(driver, tmp);
									sprintf(tmp, "system memory: shared %ld (MB), dedicated %ld (MB)\n",
												 adaptDesc.SharedSystemMemory / 1024 / 1024,
												 adaptDesc.DedicatedSystemMemory / 1024 / 1024);
									strcat(driver, tmp);
									///
									IDXGIOutput *pOutput = 0;
									for (UINT j = 0;
										 pAdapter->EnumOutputs(j, &pOutput) != DXGI_ERROR_NOT_FOUND;
										 ++j)
									{
										DXGI_OUTPUT_DESC outputDesc;
										hr = pOutput->GetDesc(&outputDesc);
										if ( SUCCEEDED(hr) ) {
											wcstombs(name, outputDesc.DeviceName, 256);
											sprintf(tmp, "display %d:     %s\n", j, name);
											strcat(driver, tmp);
											sprintf(tmp, "resolution:    %ld x %ld, (%ld, %ld, %ld, %ld)\n",
														  outputDesc.DesktopCoordinates.right - outputDesc.DesktopCoordinates.left,
														  outputDesc.DesktopCoordinates.bottom - outputDesc.DesktopCoordinates.top,
														  outputDesc.DesktopCoordinates.left, outputDesc.DesktopCoordinates.top,
														  outputDesc.DesktopCoordinates.right, outputDesc.DesktopCoordinates.bottom);
											strcat(driver, tmp);
										}
										pOutput->Release(); pOutput = 0;
									}
								}
							}
							pAdapter->Release(); pAdapter = 0;
						}
					}

				}
			}

			if (ret == FALSE && GetLastError() == ERROR_NO_MORE_ITEMS) break;

			DeviceIndex++;
			strcat(driver, "\n");
		}
	}
	SetupDiDestroyDeviceInfoList(handle);
	return true;
}

void VS_Direct3D10Render::GetDirect3DCaps(VS_D3DCAPS *caps)
{
	memset(caps, 0, sizeof(VS_D3DCAPS));
	strcat(caps->Error, m_cError);
}

bool VS_Direct3D10Render::TestD3DCaps(HWND hwnd)
{
	return ResetDevice(hwnd, 320, 240, 320, 240);
}

bool VS_Direct3D10Render::SetRectangle(HWND hwnd)
{
	if (hwnd == NULL) return false;
	POINT point ={0, 0};
	GetClientRect(hwnd, &m_rPic);
	m_rPic.right = (m_rPic.right + 3)&~3;	// divisible by 4
	m_rPic.bottom = (m_rPic.bottom + 1)&~1;	// divisible by 2
	CopyRect(&m_rViewArea, &m_rPic);
	ClientToScreen(hwnd, &point);
	m_rcb1 = m_rPic;
	m_rcb2 = m_rPic;
	float x = (float)m_biFmtDraw.biWidth/m_rPic.right;
	float y = (float)m_biFmtDraw.biHeight/m_rPic.bottom; // src/dst
	int x_offs = 0;
	int y_offs = 0;
	if (m_bKeepAspectRatio)
		if (x>y)
			y_offs = (int)((m_rPic.bottom - m_rPic.bottom*y/x)/2);
		else if (y>=x)
			x_offs = (int)((m_rPic.right - m_rPic.right*x/y)/2);


	if (y_offs>0) {
		m_rcb1.bottom = y_offs;
		m_rcb2.top = m_rcb2.bottom-y_offs;
		OffsetRect(&m_rcb1, point.x, point.y);
		OffsetRect(&m_rcb2, point.x, point.y);
	}
	else if (x_offs>0) {
		m_rcb1.right = x_offs;
		m_rcb2.left = m_rcb2.right-x_offs;
		OffsetRect(&m_rcb1, point.x, point.y);
		OffsetRect(&m_rcb2, point.x, point.y);
	}
	else {
		SetRectEmpty(&m_rcb1);
		SetRectEmpty(&m_rcb2);
	}
	OffsetRect(&m_rPic, point.x, point.y);
	InflateRect(&m_rPic, -x_offs, -y_offs);
	return true;
}

int	VS_Direct3D10Render::SetMode(eVideoRenderMode Mode, HWND hwnd)
{
	VS_AutoLock lock(this);
	if (!IsInited())
			return 1;

	if (!SetRectangle(hwnd))
		return 0;

	CRect rect;
	SetRect(&rect, 0, 0, m_rPic.right - m_rPic.left, m_rPic.bottom - m_rPic.top);
	int frameSizeMB = rect.right * rect.bottom / 256;
	m_renderFrameSizeMB = frameSizeMB;

	if (!m_IsValid) {
		m_displaydepth = 32;
		m_biFmtDraw.biCompression = BI_RGB;
		m_biFmtDraw.biBitCount	  = m_displaydepth;
		CleanBuffers();

		switch(m_biFmtIn.biCompression)		// input format
		{
		case FCC_I420:
		case FCC_IYUV:
			m_pBufferConvIn = m_pBufferIn;
			break;
		case FCC_I42S:
			m_pBufferConvIn = m_pBufferIn;
			if (m_dwStereoRender > 0) break;
		case FCC_YV12:
		case FCC_YUY2:
		case FCC_UYVY:
		case BI_RGB:
			m_pBufferConvIn = new BYTE[m_width*m_height*3/2];
			m_dwVRUse|=VR_USE_CONVIN;
			break;
		}

		m_pBufferMirrorIn = m_pBufferConvIn;
		if (m_bSelfView && m_bFlipFrame) {
			m_pBufferMirrorIn = new BYTE[m_width*m_height*3/2];
			m_dwVRUse |= VR_USE_FLIP;
		}

		// always use saturate
		m_pBufferSaturated = new BYTE[m_width*m_height*3/2];
		m_dwVRUse|=VR_USE_SATURATE;

		m_biFmtDraw.biWidth = m_width;
		m_biFmtDraw.biHeight = m_height;
		m_pBufferScaled = m_pBufferSaturated;
		m_DrawPitch = m_biFmtDraw.biWidth * m_biFmtDraw.biBitCount / 8;
		SetRect(&m_rPic2, 0, 0, m_biFmtDraw.biWidth, m_biFmtDraw.biHeight);// sourse image dimensions
		m_biFmtDraw.biSizeImage = m_biFmtDraw.biBitCount*m_biFmtDraw.biWidth*m_biFmtDraw.biHeight/8;
		m_pBufferConvOut = new BYTE [m_biFmtDraw.biSizeImage];
		m_pBufferConvOutTmp = new BYTE [m_biFmtDraw.biSizeImage];
		m_dwVRUse|=VR_USE_CONVOUT;	// always

		CopyRect(&m_rDstVid, &rect);
		CopyRect(&m_rDstSci, &rect);
		CopyRect(&rect, &m_rcb1);
		int dx = (rect.Width() == m_rDstVid.right) ? 0 : rect.Width();
		int dy = (rect.Height() == m_rDstVid.bottom) ? 0 : rect.Height();
		OffsetRect(&m_rDstSci, dx, dy);
		CopyRect(&m_rViewAreaPrev, &m_rViewArea);
		if (!ResetDevice(hwnd, m_rViewArea.right - m_rViewArea.left, m_rViewArea.bottom - m_rViewArea.top, m_biFmtDraw.biWidth, m_biFmtDraw.biHeight)) {
			return VRDDERR_CREATESURF;
		}
	} else {
		if (!EqualRect(&m_rViewAreaPrev, &m_rViewArea) || m_hwnd != hwnd) {
			HRESULT hr = D3D_OK;
			CopyRect(&m_rDstVid, &rect);
			CopyRect(&m_rDstSci, &rect);
			CopyRect(&rect, &m_rcb1);
			int dx = (rect.Width() == m_rDstVid.right) ? 0 : rect.Width();
			int dy = (rect.Height() == m_rDstVid.bottom) ? 0 : rect.Height();
			OffsetRect(&m_rDstSci, dx, dy);
			GetClientRect(hwnd, &rect);
			hr = ResetSwapChain(hwnd, m_rViewArea.right - m_rViewArea.left, m_rViewArea.bottom - m_rViewArea.top, m_biFmtDraw.biWidth, m_biFmtDraw.biHeight);
			if (FAILED(hr)) {
				DTRACE(VSTM_VRND, "failed reinit d3d");
				m_IsValid = false;
				return 1;
			}
			CopyRect(&m_rViewAreaPrev, &m_rViewArea);
		}
	}

	CreateTextureLogo(m_rViewAreaPrev.right - m_rViewAreaPrev.left, m_rViewAreaPrev.bottom - m_rViewAreaPrev.top);

	m_RenderMode = Mode;
	m_bNewFrame = TRUE;
	m_IsValid = true;
	m_hwnd = hwnd;
	return 0;
}

void VS_Direct3D10Render::DeleteTextures()
{
	for (int i = 0; i < NUM_STAGESNAME_NAME; i++) {
		if (m_pShaderResView[i]) m_pShaderResView[i]->Release(); m_pShaderResView[i] = 0;
		if (m_pTexture[i]) m_pTexture[i]->Release(); m_pTexture[i] = 0;
		if (m_pRenderTarget[i]) m_pRenderTarget[i]->Release(); m_pRenderTarget[i] = 0;
	}
}

HRESULT VS_Direct3D10Render::AllocTextures(int width, int height, DXGI_FORMAT Format)
{
	HRESULT hr;

	DeleteTextures();

	if (width == 0 || height == 0) {
		DTRACE(VSTM_VRND, "failed alloc texture: zero size");
		sprintf(m_cError, "failed alloc texture: zero size\n");
		return D3DERR_INVALIDDEVICE;
	}

	/// back buffer
	D3D10_TEXTURE2D_DESC td;
	ID3D10Texture2D* pBackBuffer = 0;
	hr = m_pSwapChain->GetBuffer(0, __uuidof(ID3D10Texture2D), reinterpret_cast<void**>(&pBackBuffer));
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed get back buffer");
		sprintf(m_cError, "failed get back buffer\n");
		return D3DERR_INVALIDDEVICE;
	}
	hr = m_pDeviceD3D10->CreateRenderTargetView(pBackBuffer, 0, &m_pRenderTarget[MAIN]);
	pBackBuffer->GetDesc(&td);
	if (pBackBuffer) pBackBuffer->Release();
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create RT for back buffer");
		sprintf(m_cError, "failed create RT for back buffer\n");
		return D3DERR_INVALIDDEVICE;
	}
	m_pDeviceD3D10->ClearRenderTargetView(m_pRenderTarget[MAIN], D3DXCOLOR(0.0f, 0.0f, 0.0f, 0.0f));
	m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[MAIN], NULL);

	unsigned int stateStage[MAIN][2] =
	{
		{			width,	2 * height},
		{			width,		height},
		{			width,		height},
		{			width,		height},
		{			width,		height},
		{m_rDstVid.right,		height},
	};

	DXGI_FORMAT stageFormat[MAIN] =
	{
		DXGI_FORMAT_R8_UNORM,
		DXGI_FORMAT_R8_UNORM,
		DXGI_FORMAT_R8_UNORM,
		DXGI_FORMAT_R8_UNORM,
		Format,
		Format,
	};

	for (int stage = 0; stage < MAIN; stage++) {
		D3D10_TEXTURE2D_DESC td;
		td.Width              = stateStage[stage][0];
		td.Height             = stateStage[stage][1];
		td.MipLevels          = 1;
		td.ArraySize          = 1;
		td.Format             = stageFormat[stage];
		td.SampleDesc.Count   = 1;
		td.SampleDesc.Quality = 0;
		td.Usage              = (stage == I420) ? D3D10_USAGE_DYNAMIC : D3D10_USAGE_DEFAULT;
		td.BindFlags          = (stage == I420) ? D3D10_BIND_SHADER_RESOURCE : D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
		td.CPUAccessFlags     = (stage == I420) ? D3D10_CPU_ACCESS_WRITE : 0;
		td.MiscFlags          = 0;
		hr = m_pDeviceD3D10->CreateTexture2D(&td, 0, &m_pTexture[stage]);
		if (FAILED(hr)) {
			DTRACE(VSTM_VRND, "failed create texture2D: %d stage", stage);
			sprintf(m_cError, "failed create texture2D: %d stage\n", stage);
			return D3DERR_INVALIDDEVICE;
		}

		if (stage != I420) {
			hr = m_pDeviceD3D10->CreateRenderTargetView(m_pTexture[stage], 0, &m_pRenderTarget[stage]);
			if (FAILED(hr)) {
				DTRACE(VSTM_VRND, "failed create RT for %d stage", stage);
				sprintf(m_cError, "failed create RT for %d stage\n", stage);
				return D3DERR_INVALIDDEVICE;
			}
		}

		D3D10_SHADER_RESOURCE_VIEW_DESC srd;
		srd.Format = stageFormat[stage];
		srd.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
		srd.Texture2D.MostDetailedMip = 0;
		srd.Texture2D.MipLevels = 1;
		hr = m_pDeviceD3D10->CreateShaderResourceView(m_pTexture[stage], &srd, &m_pShaderResView[stage]);
		if (FAILED(hr)) {
			DTRACE(VSTM_VRND, "failed create shader resource view for %d stage", stage);
			sprintf(m_cError, "failed create shader resource view for %d stage\n", stage);
			return D3DERR_INVALIDDEVICE;
		}
	}

	hr |= m_pShaderResource[YUV444_P0]->SetResource(m_pShaderResView[YUV444_P0]);
	hr |= m_pShaderResource[YUV444_P1]->SetResource(m_pShaderResView[YUV444_P1]);
	hr |= m_pShaderResource[YUV444_P2]->SetResource(m_pShaderResView[YUV444_P2]);

	return hr;
}

void VS_Direct3D10Render::ReleaseDevice()
{
	DeleteTextures();
	if (m_pVertexBuffer) m_pVertexBuffer->Release(); m_pVertexBuffer = 0;
	if (m_pVertexLayout) m_pVertexLayout->Release(); m_pVertexLayout = 0;
	if (m_pRS) m_pRS->Release(); m_pRS = 0;
	if (m_pEffect) m_pEffect->Release(); m_pEffect = 0;
	if (m_pBlendState) m_pBlendState->Release(); m_pBlendState = 0;
	if (m_pSwapChain) m_pSwapChain->Release(); m_pSwapChain = 0;
	if (m_pDXGIFactory) m_pDXGIFactory->Release(); m_pDXGIFactory = 0;
	if (m_pDXGIAdapter) m_pDXGIAdapter->Release(); m_pDXGIAdapter = 0;
	if (m_pDXGIDevice) m_pDXGIDevice->Release(); m_pDXGIDevice = 0;
	if (m_pDeviceD3D10) m_pDeviceD3D10->Release(); m_pDeviceD3D10 = 0;
}

bool VS_Direct3D10Render::ResetDevice(HWND hwnd, int back_buffer_width, int back_buffer_height, int width, int height)
{
	HRESULT hr;
	if(FAILED(hr = CreateDevice(hwnd, back_buffer_width, back_buffer_height)) || FAILED(hr = AllocTextures(width, height))) {
		return false;
	}
	return true;
}

HRESULT VS_Direct3D10Render::CreateDevice3D(HWND hwnd, int width, int height)
{
	HRESULT hr;

	hr = g_CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)(&m_pDXGIFactory));
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create dxgi factory");
		sprintf(m_cError, "failed create dxgi factory\n");
		return hr;
	}

	hr = m_pDXGIFactory->EnumAdapters(0, &m_pDXGIAdapter);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create IDXGIAdapter");
		sprintf(m_cError, "failed create IDXGIAdapter\n");
		return hr;
	}

	DXGI_SWAP_CHAIN_DESC sd;
	sd.BufferDesc.Width  = width;
	sd.BufferDesc.Height = height;
	sd.BufferDesc.RefreshRate.Numerator = 0;
	sd.BufferDesc.RefreshRate.Denominator = 1;
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	sd.SampleDesc.Count   = 1;
	sd.SampleDesc.Quality = 0;
	sd.BufferUsage  = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sd.BufferCount  = 1;
	sd.OutputWindow = hwnd;
	sd.Windowed     = true;
	sd.SwapEffect   = DXGI_SWAP_EFFECT_DISCARD;
	sd.Flags        = 0;

	unsigned int createDeviceFlags = 0;
//#if defined(DEBUG) || defined(_DEBUG)
//    createDeviceFlags |= D3D10_CREATE_DEVICE_DEBUG;
//#endif

	hr = g_D3D10CreateDeviceAndSwapChain(m_pDXGIAdapter, D3D10_DRIVER_TYPE_HARDWARE, 0, createDeviceFlags, D3D10_SDK_VERSION, &sd, &m_pSwapChain, &m_pDeviceD3D10);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create Direct3D10 device and SwapChain");
		sprintf(m_cError, "failed create Direct3D10 device and SwapChain\n");
		return hr;
	}
	hr = m_pDeviceD3D10->QueryInterface(__uuidof(IDXGIDevice), (void **)&m_pDXGIDevice);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed query interface DXGIDevice");
		sprintf(m_cError, "failed query interface DXGIDevice\n");
	}

	m_pDXGIDevice->SetGPUThreadPriority(7);

	return hr;
}

static unsigned char fx_processing_frame_i420[] =
{
	0x17, 0x13, 0x00, 0x00, 0x19, 0x91, 0xf6, 0xfd, 0x1f, 0x6c, 0x3a, 0xeb, 0xc5, 0x4c, 0xc7, 0xe7,
	0xab, 0x85, 0xaa, 0x65, 0x0b, 0xee, 0xdd, 0x26, 0x92, 0x8f, 0xa1, 0x03, 0x4f, 0xbf, 0xb0, 0x46,
	0x03, 0x09, 0x43, 0xa9, 0x3c, 0x2e, 0xde, 0x2b, 0xad, 0x99, 0x72, 0x02, 0x3b, 0x81, 0xae, 0xfd,
	0xa6, 0xcd, 0x4c, 0x59, 0x8c, 0xf9, 0x87, 0x0b, 0x3d, 0xcd, 0xc9, 0xc2, 0x77, 0x11, 0x81, 0x0a,
	0x9a, 0xa0, 0x5f, 0x7c, 0x58, 0x16, 0x38, 0x4e, 0x9e, 0xcc, 0x6a, 0x37, 0x2d, 0x87, 0x3b, 0xed,
	0x3f, 0x34, 0x51, 0xa3, 0xd8, 0xda, 0xb5, 0x25, 0x66, 0x80, 0x57, 0x51, 0xf1, 0x27, 0xfb, 0x12,
	0x22, 0xdb, 0x97, 0x5b, 0xae, 0xcf, 0x48, 0x95, 0x5a, 0x0e, 0x7b, 0x06, 0x82, 0x8f, 0x1d, 0x6c,
	0x74, 0xc2, 0x59, 0x20, 0x30, 0x8d, 0x31, 0xd4, 0x5a, 0x20, 0x0b, 0xc6, 0x0b, 0xf7, 0xc6, 0x50,
	0x6e, 0x31, 0xa2, 0x5d, 0xc2, 0xf4, 0xfa, 0x95, 0xe7, 0x00, 0x92, 0x88, 0x9b, 0x86, 0x61, 0xfc,
	0x36, 0xdf, 0x3c, 0x3a, 0xbf, 0x95, 0x72, 0x21, 0xaa, 0x01, 0xe4, 0x02, 0xd9, 0x47, 0x81, 0x16,
	0xf5, 0x86, 0xda, 0x19, 0xa8, 0xc4, 0xd5, 0xd7, 0xaa, 0xaf, 0x4a, 0x73, 0xcf, 0x09, 0x9d, 0x41,
	0xbe, 0x79, 0xed, 0x96, 0x35, 0x18, 0x62, 0x03, 0xc2, 0xb9, 0x43, 0x45, 0x9b, 0xa3, 0x67, 0xd0,
	0xc9, 0xa6, 0xd5, 0x68, 0x2d, 0xe2, 0x9c, 0xfa, 0x97, 0x29, 0xcc, 0x24, 0x8e, 0x4d, 0xa8, 0xe6,
	0x05, 0xb2, 0x96, 0xdd, 0x07, 0x02, 0xf6, 0x9a, 0x36, 0x7c, 0x93, 0x0a, 0x1b, 0xb1, 0x2b, 0x02,
	0xa0, 0x51, 0xa1, 0x63, 0x11, 0x5b, 0x3d, 0x54, 0xb7, 0xd8, 0xaf, 0xab, 0x65, 0xfe, 0xb4, 0x2f,
	0x14, 0x89, 0x89, 0x45, 0x1c, 0xf5, 0xd6, 0xef, 0x3d, 0x76, 0xab, 0x39, 0x57, 0x65, 0xab, 0xdc,
	0x5d, 0x77, 0x10, 0x6c, 0xc4, 0xd2, 0xc8, 0x0f, 0x56, 0x33, 0xb9, 0xe6, 0x38, 0xc1, 0x89, 0x90,
	0x81, 0xe0, 0x09, 0x85, 0x9c, 0x69, 0xc6, 0xbc, 0x1a, 0x18, 0x83, 0x99, 0xa9, 0xda, 0xae, 0x94,
	0x67, 0xbc, 0xad, 0xb1, 0xb9, 0xfe, 0xf5, 0x4c, 0x90, 0x0d, 0x5e, 0x6d, 0xd2, 0x40, 0x45, 0x81,
	0x72, 0x8d, 0xbd, 0x87, 0x33, 0xf2, 0x03, 0xae, 0x15, 0xe8, 0x19, 0xa3, 0xd5, 0x9b, 0x34, 0x41,
	0x15, 0x38, 0x52, 0xcc, 0xae, 0x17, 0x09, 0x31, 0x84, 0xa9, 0xb8, 0x1f, 0x75, 0xa5, 0x00, 0x4f,
	0x29, 0x2e, 0xbf, 0x27, 0x5a, 0x8f, 0x25, 0x6a, 0x86, 0x7c, 0x55, 0xbb, 0x84, 0x80, 0x72, 0x8f,
	0x34, 0x43, 0xdd, 0x6d, 0xf6, 0xf5, 0x62, 0x7a, 0x62, 0xc4, 0x7b, 0xd0, 0xd1, 0x8e, 0x13, 0xf3,
	0xc4, 0xf8, 0x50, 0xf5, 0xac, 0x97, 0x1c, 0x5b, 0xe7, 0x5b, 0xd3, 0xa4, 0xca, 0xa2, 0xd9, 0xae,
	0x59, 0xcd, 0x2f, 0xfb, 0x1d, 0x3e, 0x63, 0xb5, 0x23, 0x4e, 0x4f, 0x73, 0x1a, 0x7c, 0xe4, 0x24,
	0x7f, 0x8f, 0xa9, 0x89, 0x48, 0x7c, 0x31, 0xbc, 0x61, 0x66, 0x61, 0x94, 0xf7, 0x54, 0x49, 0x5c,
	0x25, 0x2a, 0xd4, 0x54, 0x0d, 0xf4, 0x5a, 0x98, 0xe4, 0xc8, 0x37, 0xd0, 0xd6, 0xc7, 0xbf, 0x61,
	0xe1, 0xbd, 0xe8, 0x94, 0x09, 0x8d, 0x1e, 0xa1, 0x55, 0x73, 0x74, 0xa5, 0x4f, 0x8f, 0x26, 0x30,
	0x99, 0x4b, 0x2c, 0x14, 0xb1, 0x4c, 0x33, 0x9f, 0x94, 0x1c, 0xbb, 0xde, 0x3c, 0xe0, 0x83, 0xfc,
	0x37, 0xf2, 0x68, 0x44, 0xae, 0x0d, 0x7e, 0x3f, 0xb1, 0x1f, 0x25, 0x32, 0x4c, 0x28, 0x9c, 0xba,
	0xb0, 0x0f, 0x1d, 0xeb, 0xeb, 0xe9, 0x6f, 0xc5, 0x75, 0xa1, 0xae, 0x79, 0x56, 0x46, 0x06, 0x6c,
	0xc6, 0x62, 0xfc, 0xa9, 0xf7, 0xe1, 0x13, 0x34, 0x8e, 0x5f, 0x38, 0xf3, 0xe9, 0xf3, 0xde, 0x26,
	0xba, 0x2c, 0xf5, 0x51, 0x50, 0x16, 0x30, 0x27, 0xa6, 0x37, 0x79, 0xcd, 0x3a, 0x3b, 0x61, 0x66,
	0x51, 0xdf, 0x91, 0xb6, 0x1b, 0x35, 0xe4, 0xac, 0xb5, 0x26, 0x4a, 0xc1, 0xca, 0xd5, 0x11, 0x9d,
	0x27, 0xe2, 0x95, 0xfb, 0xf0, 0xb2, 0x7b, 0x3a, 0x06, 0x82, 0x1c, 0x8e, 0x47, 0xc1, 0x01, 0x71,
	0xb5, 0x58, 0x9b, 0x75, 0x30, 0x09, 0x84, 0x92, 0x45, 0xd8, 0x8b, 0x61, 0x0f, 0x83, 0xc6, 0x26,
	0xbe, 0x02, 0x17, 0xbb, 0x6a, 0xd6, 0xfc, 0x85, 0xaf, 0x63, 0x57, 0xf1, 0x4e, 0xe7, 0xc7, 0x21,
	0xda, 0x2c, 0x7c, 0xb8, 0xbd, 0xb1, 0x27, 0x22, 0x76, 0x7d, 0x00, 0xc4, 0x14, 0x05, 0xf5, 0x0f,
	0x8c, 0xd5, 0x97, 0x82, 0xa8, 0xd0, 0xbe, 0x83, 0x4a, 0x9c, 0xf6, 0x4e, 0x31, 0x5f, 0xe1, 0xe9,
	0x71, 0xc9, 0xfa, 0x64, 0x15, 0x17, 0x98, 0xe7, 0x04, 0x97, 0x67, 0x42, 0xed, 0x50, 0x7e, 0x0c,
	0xef, 0x02, 0x94, 0xc2, 0xa4, 0xed, 0xd2, 0x94, 0xf9, 0xe4, 0x2f, 0x72, 0xc2, 0x49, 0x9e, 0x7e,
	0x34, 0x46, 0x77, 0x20, 0xe5, 0x95, 0xff, 0xf7, 0xca, 0x8e, 0xd2, 0x51, 0x85, 0x76, 0xa1, 0xc0,
	0x07, 0x1d, 0x58, 0x38, 0x30, 0x65, 0xc8, 0xde, 0xfd, 0x92, 0x8c, 0x7c, 0xc7, 0xb1, 0x9f, 0x69,
	0xd4, 0x19, 0x9a, 0xed, 0xe9, 0x23, 0xfb, 0x8b, 0x59, 0x61, 0x29, 0xaa, 0xae, 0x12, 0x78, 0xd2,
	0xee, 0xdf, 0xa0, 0x79, 0x8f, 0x46, 0x1c, 0xc1, 0x2c, 0x0f, 0x35, 0xf0, 0x94, 0x91, 0x6e, 0x57,
	0xc5, 0x65, 0xca, 0xf1, 0x85, 0x1a, 0xe3, 0xe7, 0x48, 0x06, 0xf1, 0x56, 0x4a, 0xe6, 0x83, 0x16,
	0xa7, 0x99, 0xd1, 0x0e, 0xb4, 0x0f, 0x7a, 0xea, 0x05, 0x5e, 0x01, 0x91, 0x68, 0x8e, 0x1f, 0xad,
	0xec, 0xc3, 0xca, 0xa6, 0xe2, 0x29, 0x9a, 0x84, 0x4d, 0xa2, 0x91, 0xfa, 0x1d, 0xf8, 0x5e, 0xbd,
	0xf2, 0xe5, 0x35, 0x29, 0xd9, 0xd6, 0xe7, 0x55, 0x3d, 0x95, 0x7e, 0x25, 0xcd, 0xc2, 0xb4, 0xcf,
	0x15, 0x19, 0xf0, 0x23, 0x74, 0x3c, 0x22, 0x73, 0x1e, 0x7e, 0x42, 0xa5, 0x7f, 0x5b, 0x2b, 0xb7,
	0xb3, 0xa9, 0xd5, 0xda, 0xcf, 0x79, 0xd5, 0x8b, 0x2f, 0xf7, 0x28, 0x12, 0xd5, 0x69, 0x26, 0xb0,
	0x75, 0x02, 0x0b, 0xc9, 0xa5, 0xa5, 0x2b, 0x71, 0x8e, 0x2f, 0xc3, 0xe9, 0x53, 0x8f, 0xef, 0x8f,
	0xe3, 0x9b, 0x88, 0xed, 0x2a, 0xd6, 0x88, 0xb0, 0x55, 0x63, 0x20, 0xc0, 0x13, 0x8d, 0x9d, 0xdf,
	0xd2, 0xc3, 0x35, 0x51, 0xe6, 0xa3, 0xe6, 0x13, 0xfb, 0xb0, 0xa5, 0xe1, 0x1b, 0x2c, 0xc4, 0x0b,
	0x0d, 0x8b, 0xc4, 0xcb, 0x13, 0xdf, 0xd3, 0x07, 0x72, 0x0a, 0x1e, 0x5b, 0xaf, 0x74, 0x12, 0x9e,
	0x3b, 0xb1, 0x57, 0x08, 0x6b, 0x07, 0xff, 0x5c, 0xd7, 0xe7, 0x20, 0xb5, 0x13, 0x24, 0x9e, 0xbc,
	0x01, 0x95, 0xfd, 0x54, 0x35, 0x2d, 0x51, 0xd7, 0xca, 0x65, 0xa9, 0x4b, 0x86, 0xc5, 0x7f, 0x84,
	0xc0, 0xbc, 0x03, 0xf4, 0x0e, 0x7e, 0xa6, 0xd3, 0xeb, 0x5b, 0x99, 0x1d, 0x42, 0xf3, 0x06, 0x4a,
	0xd1, 0xe4, 0xbd, 0xb5, 0xda, 0xc5, 0x44, 0x91, 0xca, 0xec, 0x97, 0x2b, 0xf5, 0x54, 0x53, 0xe4,
	0xba, 0xc5, 0x90, 0x6b, 0x20, 0x56, 0xaa, 0x3f, 0x1f, 0x55, 0xdf, 0x87, 0x3f, 0x55, 0x61, 0x3d,
	0xd6, 0xa7, 0x9a, 0xd6, 0x64, 0xfa, 0x84, 0x82, 0xa2, 0x4a, 0xad, 0xbe, 0x90, 0xa9, 0x89, 0xac,
	0xc9, 0xfc, 0xe4, 0xb0, 0x0d, 0x8b, 0x73, 0x16, 0xe5, 0x18, 0xb0, 0x10, 0x60, 0x0d, 0x31, 0x88,
	0x6f, 0x43, 0xdf, 0x23, 0xbc, 0xf2, 0xbf, 0x44, 0x0d, 0x6d, 0x72, 0xcb, 0xdb, 0x19, 0x79, 0x9c,
	0xbf, 0x3c, 0xae, 0x07, 0x12, 0x9d, 0xad, 0xa0, 0x89, 0x78, 0x2f, 0x4f, 0x89, 0x43, 0xa2, 0x0a,
	0x68, 0xf2, 0xae, 0x81, 0xbd, 0x1b, 0xcf, 0xba, 0xe9, 0xd2, 0x36, 0xdd, 0xdc, 0xbe, 0x1a, 0xe8,
	0xd3, 0xf8, 0x06, 0x34, 0x75, 0xcb, 0x0a, 0xbf, 0x37, 0xec, 0x53, 0x54, 0xc2, 0x76, 0x49, 0x4a,
	0x73, 0xb1, 0x40, 0x42, 0x5b, 0x59, 0xbd, 0xd3, 0xcb, 0x64, 0xdf, 0xff, 0xce, 0x19, 0x44, 0x0e,
	0xa8, 0x26, 0x39, 0xf5, 0x18, 0x9f, 0x38, 0x99, 0x99, 0xe4, 0x10, 0x37, 0xaf, 0x7d, 0x39, 0xbc,
	0x52, 0x8d, 0x8b, 0xb3, 0xd3, 0xc7, 0xa2, 0x8a, 0xd8, 0x6f, 0xed, 0x23, 0x2f, 0xfd, 0x7f, 0x85,
	0xfe, 0xf4, 0x3f, 0xf4, 0xe5, 0x0a, 0x69, 0xaa, 0x74, 0xd7, 0xa2, 0x40, 0x1a, 0x5a, 0xec, 0x15,
	0xb9, 0x1f, 0x4f, 0x57, 0xb2, 0x09, 0x4e, 0x53, 0xfe, 0x38, 0x02, 0x0a, 0x6c, 0xe4, 0x5b, 0xbd,
	0x7a, 0x0c, 0x0c, 0xa6, 0xec, 0x33, 0xf0, 0xff, 0xec, 0x5a, 0x89, 0xb0, 0xae, 0x75, 0x20, 0x50,
	0xcd, 0xfc, 0x50, 0x6c, 0x30, 0x9b, 0xbf, 0xc3, 0x44, 0x27, 0x05, 0xb8, 0x0d, 0xf3, 0x7a, 0x0f,
	0xdc, 0x1b, 0x59, 0x09, 0x3a, 0xd1, 0xc1, 0x9d, 0xe8, 0x78, 0x62, 0xbd, 0xc2, 0x8a, 0x47, 0xdf,
	0x6c, 0xd5, 0x54, 0xfd, 0x2e, 0x85, 0x7a, 0x7f, 0xd6, 0x4b, 0x15, 0x2c, 0x94, 0xf6, 0x1f, 0x6b,
	0x15, 0xe8, 0xda, 0x5b, 0x8f, 0xac, 0x00, 0x1f, 0xbc, 0x84, 0x62, 0x4c, 0xc1, 0x79, 0x52, 0x6d,
	0x78, 0x56, 0x29, 0x10, 0x15, 0x40, 0x81, 0xba, 0x53, 0xdf, 0xb0, 0xfa, 0x5a, 0x54, 0x1b, 0xf7,
	0x7f, 0x97, 0x20, 0xf1, 0x2b, 0xc8, 0x69, 0x19, 0xbd, 0xb5, 0x7c, 0xa5, 0x8b, 0x27, 0x31, 0x62,
	0xe5, 0x8d, 0xcc, 0x81, 0x8f, 0x0e, 0x3f, 0xea, 0xe9, 0xd3, 0x0e, 0xb3, 0xe0, 0x76, 0xec, 0xb7,
	0x57, 0xcc, 0x05, 0xdf, 0x55, 0xe0, 0x5c, 0x37, 0x4e, 0xad, 0x7d, 0x0a, 0x77, 0x72, 0x82, 0xb8,
	0x6a, 0x5f, 0x88, 0x2f, 0xe7, 0x69, 0x57, 0xb8, 0x9d, 0x74, 0x7e, 0xd9, 0xbb, 0x1a, 0x91, 0x2b,
	0xdc, 0x12, 0x6e, 0xaf, 0xe3, 0x30, 0x60, 0xfd, 0xea, 0xc2, 0x9d, 0x01, 0xb1, 0x16, 0xd3, 0x4a,
	0x91, 0xbd, 0x2a, 0x3a, 0xdc, 0xa9, 0x94, 0x02, 0xe1, 0x42, 0x9c, 0xf5, 0x39, 0x61, 0xe1, 0x29,
	0x4c, 0x81, 0x1c, 0xba, 0xb0, 0xfa, 0x8e, 0x1c, 0xf7, 0xc9, 0x77, 0xa4, 0x6f, 0xd7, 0x37, 0x4e,
	0x45, 0xea, 0xda, 0xb2, 0x9f, 0xc3, 0xc6, 0x2c, 0xea, 0x0c, 0x73, 0xb4, 0x36, 0xad, 0xa7, 0x7a,
	0x5f, 0xfb, 0x29, 0xe4, 0x01, 0xd6, 0x3c, 0x3d, 0x9f, 0x12, 0x13, 0x22, 0xa8, 0x15, 0x4b, 0xe1,
	0xe2, 0x26, 0x3d, 0xca, 0x40, 0x00, 0x58, 0xca, 0xea, 0xa8, 0x89, 0x0a, 0xb2, 0x75, 0x2b, 0x0f,
	0x82, 0x7d, 0xaa, 0xca, 0x1e, 0x08, 0xfe, 0x6e, 0x27, 0xd9, 0xcf, 0x77, 0xbf, 0x43, 0x15, 0x50,
	0xee, 0x66, 0xa0, 0xc3, 0x97, 0x06, 0x82, 0xd5, 0x25, 0xc7, 0x42, 0x5a, 0xfa, 0x61, 0x21, 0xb9,
	0xa1, 0xbb, 0xd8, 0xf3, 0x93, 0xa0, 0xbd, 0xbb, 0xe6, 0x55, 0x90, 0xf5, 0xda, 0x3d, 0x99, 0x1f,
	0xd9, 0x6d, 0x5c, 0x6c, 0x91, 0x23, 0xa4, 0x48, 0xa1, 0xdf, 0x96, 0xfe, 0xff, 0x18, 0x3d, 0x45,
	0x24, 0xad, 0xd1, 0x84, 0x11, 0xb8, 0x08, 0x94, 0x32, 0x78, 0xfb, 0xb5, 0x61, 0xc0, 0x11, 0x7c,
	0xfa, 0x97, 0x3d, 0x7b, 0xf6, 0x96, 0x36, 0xf1, 0x65, 0x03, 0xfa, 0x2b, 0x78, 0xb0, 0x0d, 0x5c,
	0xc0, 0x90, 0x38, 0x44, 0xad, 0xe5, 0x96, 0xa8, 0xbc, 0x16, 0x32, 0xde, 0x93, 0x4e, 0x82, 0xe4,
	0x9b, 0xf4, 0x2a, 0x6c, 0x8c, 0xc5, 0xd3, 0x30, 0x36, 0xdc, 0x52, 0xc4, 0x77, 0x46, 0x98, 0x09,
	0xe7, 0xb2, 0x66, 0x3c, 0x74, 0xad, 0x58, 0x3d, 0x8b, 0xce, 0xdf, 0x00, 0x50, 0xb9, 0x3b, 0xdc,
	0x80, 0xe7, 0x4e, 0x2e, 0x9d, 0xa6, 0x49, 0xcc, 0x9b, 0xe0, 0x03, 0x8b, 0x63, 0x72, 0x49, 0x41,
	0x4c, 0xec, 0x4b, 0x70, 0x59, 0x05, 0x4e, 0x8d, 0x8f, 0x28, 0xc3, 0x02, 0xab, 0x90, 0x90, 0xc9,
	0x52, 0x6e, 0x36, 0x19, 0x5e, 0x95, 0xb9, 0x4b, 0x24, 0x07, 0xbe, 0xa2, 0xa6, 0x6c, 0xea, 0x80,
	0xaf, 0x72, 0x51, 0xa6, 0x70, 0x76, 0x1d, 0x3c, 0xa9, 0xce, 0x60, 0x7f, 0xed, 0xb2, 0x12, 0x20,
	0x8a, 0x19, 0x6f, 0x7d, 0x5d, 0xb7, 0x6e, 0x62, 0xc7, 0x8f, 0xf5, 0xc2, 0xf6, 0x49, 0xe8, 0x85,
	0x34, 0x7e, 0xb9, 0xc4, 0x83, 0xb3, 0x55, 0xfb, 0x47, 0x1a, 0x63, 0x58, 0x3d, 0xdf, 0x90, 0x3b,
	0xa4, 0x1b, 0x43, 0xc4, 0x44, 0x86, 0xfb, 0x32, 0x90, 0x2c, 0x43, 0x59, 0x28, 0xc0, 0x37, 0x6a,
	0x9d, 0xd5, 0xc1, 0x70, 0xc1, 0xe9, 0xb3, 0x8a, 0xb3, 0xda, 0x04, 0x7f, 0x2e, 0x01, 0xce, 0x19,
	0x78, 0xb0, 0xf0, 0x67, 0x7e, 0xae, 0x8a, 0x3d, 0x92, 0x4c, 0x9f, 0xa3, 0xd4, 0xf3, 0xad, 0xfc,
	0x57, 0x24, 0x10, 0xca, 0xe3, 0x2f, 0x38, 0x29, 0xc4, 0xa7, 0x7f, 0x62, 0x7e, 0x4e, 0x2a, 0x81,
	0x42, 0xde, 0xb3, 0x3e, 0x3f, 0x04, 0xdb, 0x21, 0xdb, 0x84, 0x53, 0x8b, 0x79, 0x0a, 0x3d, 0xbe,
	0xcc, 0xeb, 0xf4, 0x73, 0x6e, 0x6d, 0xdf, 0xd4, 0xcd, 0xd8, 0xe2, 0xcb, 0x13, 0x14, 0x9c, 0x11,
	0x92, 0xc5, 0x42, 0xce, 0xab, 0x60, 0xfb, 0x19, 0x7b, 0x63, 0x93, 0x43, 0x30, 0x2b, 0xbe, 0x83,
	0x1a, 0xd5, 0x02, 0x0d, 0x43, 0xfb, 0x6d, 0x08, 0xcf, 0xa2, 0x92, 0x94, 0xab, 0xd4, 0x11, 0xaf,
	0x60, 0x49, 0x55, 0x15, 0x6a, 0xf0, 0xf6, 0x2b, 0xbb, 0x71, 0x49, 0x29, 0xd8, 0xc5, 0xf6, 0x42,
	0x70, 0xff, 0xe3, 0x19, 0xca, 0xa8, 0xb2, 0xf4, 0xc9, 0x68, 0x84, 0x53, 0xea, 0x29, 0x97, 0xe5,
	0x26, 0xf3, 0x5b, 0x82, 0x2c, 0x18, 0x9f, 0x3d, 0x79, 0x7f, 0x7b, 0x24, 0x54, 0x58, 0x15, 0xe1,
	0x1b, 0xe7, 0xd1, 0xb6, 0xcb, 0x72, 0x20, 0x43, 0x5c, 0x11, 0xa5, 0x97, 0xc8, 0xdd, 0x02, 0x53,
	0xe4, 0xd9, 0xb5, 0xfa, 0x81, 0xc1, 0x68, 0x88, 0xfd, 0xe9, 0xb9, 0x7b, 0x12, 0x78, 0x79, 0xc6,
	0xc8, 0x67, 0xeb, 0xce, 0xd7, 0x0e, 0x1e, 0xe4, 0xf0, 0xf3, 0xe3, 0x6b, 0xa7, 0x47, 0xc0, 0x5b,
	0x55, 0x5d, 0x64, 0x9d, 0x58, 0xfc, 0x45, 0x39, 0xf1, 0x98, 0x48, 0x36, 0x8a, 0x89, 0x4f, 0x56,
	0xe3, 0x08, 0x0d, 0xa9, 0x54, 0x9a, 0xf0, 0x44, 0xa7, 0xb3, 0x4f, 0xbf, 0x3c, 0xed, 0xfd, 0x2b,
	0x26, 0xad, 0x9a, 0xe6, 0xdd, 0x8b, 0x29, 0xdb, 0xc6, 0xbc, 0x86, 0xb2, 0xe3, 0xe3, 0xd3, 0x33,
	0x58, 0x5a, 0x79, 0x37, 0xa7, 0x7d, 0x37, 0x8b, 0xa8, 0xda, 0x39, 0x06, 0xf2, 0xae, 0x1c, 0x78,
	0x29, 0xa6, 0xa7, 0x54, 0x19, 0x9c, 0x5e, 0xff, 0xb8, 0xa0, 0x24, 0xa4, 0xdd, 0xb4, 0xf9, 0xae,
	0xd3, 0xd4, 0xac, 0xba, 0x91, 0xde, 0xe9, 0xf6, 0x3f, 0x40, 0x28, 0x70, 0xb5, 0x70, 0x64, 0x43,
	0xe1, 0x62, 0xbe, 0x5b, 0xd2, 0x5e, 0x9a, 0x7e, 0x09, 0x20, 0xe4, 0x95, 0x58, 0x0d, 0x2d, 0x72,
	0x68, 0x83, 0xf9, 0xa6, 0x97, 0x26, 0x17, 0x8f, 0x1d, 0xce, 0xcc, 0xcd, 0x4e, 0x35, 0x2f, 0xaf,
	0xa0, 0x68, 0x52, 0x10, 0x93, 0xf3, 0x8e, 0xa7, 0x7f, 0xf4, 0xc4, 0xbb, 0xc7, 0x2a, 0x2a, 0xb0,
	0xcf, 0x27, 0xeb, 0x3c, 0x13, 0xb1, 0xb6, 0x80, 0x75, 0xeb, 0x0b, 0xac, 0x1c, 0x35, 0x77, 0x6a,
	0x76, 0xfe, 0x57, 0x37, 0xbd, 0x0d, 0x1f, 0xe9, 0xa0, 0xed, 0x47, 0xc3, 0x96, 0xd3, 0x91, 0xd6,
	0x34, 0xce, 0x72, 0x2b, 0x8a, 0xbd, 0x80, 0xee, 0xca, 0x03, 0xe7, 0xac, 0xce, 0xc0, 0xeb, 0x8f,
	0x46, 0xc4, 0x2e, 0x3b, 0x01, 0x7a, 0xce, 0xaf, 0xc9, 0x01, 0x6d, 0x96, 0x60, 0xf5, 0xd4, 0x48,
	0x4a, 0x43, 0x03, 0xf6, 0xf6, 0x6d, 0x21, 0x52, 0x6c, 0x0e, 0xed, 0x2b, 0xea, 0xda, 0xd7, 0x42,
	0xe1, 0x3b, 0xeb, 0x35, 0xb2, 0xad, 0x19, 0xe1, 0xc8, 0x92, 0xd2, 0xc2, 0x8d, 0xbf, 0x6f, 0xc0,
	0x23, 0x8b, 0xc9, 0x22, 0x5f, 0x55, 0x84, 0xe4, 0x97, 0x77, 0xde, 0xbe, 0x17, 0x9e, 0x4f, 0x25,
	0xc2, 0xe3, 0x4f, 0x96, 0x3e, 0x5b, 0xaa, 0x3b, 0x2c, 0xd1, 0x66, 0x21, 0x11, 0x70, 0x13, 0x24,
	0x31, 0xf6, 0xf8, 0x09, 0xbf, 0xae, 0x7d, 0x5d, 0x8b, 0x2f, 0xd1, 0x46, 0x52, 0xd4, 0x7d, 0xca,
	0xbf, 0x43, 0x3b, 0xc5, 0x28, 0x96, 0xd7, 0xcc, 0x99, 0xaa, 0xe0, 0x7c, 0x6e, 0x77, 0x0c, 0x44,
	0xb8, 0x75, 0x47, 0x93, 0xa1, 0x1c, 0x4d, 0xd2, 0xb7, 0x83, 0x99, 0x38, 0x99, 0x85, 0x50, 0xe3,
	0x0a, 0x96, 0xe4, 0xfb, 0x0b, 0x84, 0xae, 0x37, 0xc6, 0x8f, 0xa4, 0x7c, 0x37, 0x9a, 0x1a, 0xda,
	0x96, 0xda, 0xdf, 0x2b, 0x8a, 0x52, 0x17, 0xac, 0xc6, 0x73, 0x1d, 0xe5, 0xf1, 0xc9, 0xfd, 0xc6,
	0xf8, 0x99, 0x5c, 0xef, 0xea, 0x1a, 0xaa, 0xc8, 0xbf, 0xc5, 0x3a, 0xc7, 0xb0, 0x0e, 0xa5, 0xd6,
	0xd9, 0x6e, 0xe8, 0x28, 0xe2, 0xc8, 0x1e, 0xff, 0x7f, 0x48, 0x70, 0xbc, 0x7e, 0x77, 0x3d, 0x2b,
	0xeb, 0xfa, 0xc7, 0xf8, 0x8b, 0x34, 0x6d, 0x39, 0x64, 0xcf, 0xe6, 0x19, 0x8c, 0xd1, 0xf5, 0x55,
	0xe4, 0x3a, 0xd8, 0xd1, 0x9f, 0xda, 0xb3, 0xb1, 0x5e, 0x16, 0xfd, 0x09, 0xde, 0x25, 0x63, 0x9e,
	0x99, 0x40, 0x56, 0x26, 0x50, 0x19, 0x2f, 0xd6, 0x7d, 0xd6, 0xdc, 0x54, 0x7c, 0xac, 0x07, 0x58,
	0x0a, 0x03, 0xb8, 0x23, 0xae, 0x23, 0xbb, 0x18, 0xcf, 0xae, 0x8a, 0x61, 0x1c, 0x76, 0x87, 0x06,
	0x4a, 0x84, 0x1c, 0xe3, 0xcd, 0xc9, 0xe9, 0x15, 0x41, 0x83, 0xef, 0x04, 0xbc, 0xfe, 0x9c, 0x72,
	0x13, 0xbc, 0xc2, 0x73, 0x68, 0xcb, 0x19, 0x1f, 0x8d, 0x0e, 0x03, 0xd3, 0x65, 0xca, 0x72, 0x97,
	0x5f, 0xbf, 0xcc, 0x40, 0x53, 0x1a, 0x86, 0x51, 0xf6, 0x13, 0x4a, 0xf4, 0xe8, 0x3c, 0xbb, 0xcd,
	0xfa, 0xab, 0xba, 0xa6, 0xc9, 0x8b, 0xef, 0x8d, 0x60, 0x86, 0x63, 0xc1, 0xd8, 0xbc, 0x0f, 0x9d,
	0x4d, 0xbe, 0x04, 0x1b, 0xde, 0x3a, 0xfc, 0xf9, 0xa3, 0x2b, 0x2d, 0xf4, 0x03, 0xe9, 0x49, 0xe1,
	0xe9, 0x94, 0x3f, 0x73, 0xc5, 0x9c, 0xd5, 0x3a, 0xdf, 0xd5, 0x01, 0x38, 0x03, 0xf0, 0x8f, 0x48,
	0xff, 0xf8, 0x11, 0xdd, 0xe6, 0xf3, 0xbc, 0xb2, 0x43, 0x0b, 0x18, 0xbe, 0x60, 0x96, 0xbf, 0xef,
	0x66, 0xc3, 0x11, 0x22, 0x3c, 0xa0, 0xc2, 0x28, 0xf2, 0x68, 0x37, 0xa0, 0x21, 0xf4, 0x0d, 0x38,
	0xbe, 0x54, 0x5a, 0xcb, 0x3f, 0x80, 0x39, 0xe2, 0xe9, 0x11, 0x09, 0x33, 0x53, 0x73, 0x77, 0x26,
	0x18, 0x89, 0x85, 0xa2, 0x85, 0x31, 0x7b, 0xba, 0x1f, 0xe0, 0x7a, 0x95, 0xa6, 0x64, 0xc0, 0x3c,
	0x38, 0xbc, 0xbc, 0xec, 0xc0, 0x36, 0x3b, 0x73, 0x2b, 0xc7, 0x29, 0x6c, 0xac, 0x09, 0x63, 0x57,
	0x2d, 0x3d, 0x23, 0xf2, 0x03, 0x58, 0x9e, 0x20, 0xa6, 0x49, 0xfa, 0x88, 0xa8, 0x17, 0x64, 0x17,
	0x49, 0x12, 0x06, 0x12, 0x67, 0xb9, 0x75, 0xec, 0x74, 0xda, 0xe9, 0x05, 0xb4, 0xa8, 0x8b, 0x57,
	0xc6, 0x2c, 0xcc, 0x1b, 0x87, 0x2b, 0xc0, 0xbc, 0xc6, 0x3a, 0xaa, 0x2a, 0x4b, 0x3f, 0x3b, 0x36,
	0xf8, 0x85, 0x39, 0xf3, 0x6f, 0x6c, 0xe1, 0x72, 0x9d, 0xba, 0x91, 0x37, 0x27, 0xdf, 0xfb, 0xbf,
	0x7d, 0x17, 0xa9, 0xa6, 0x5b, 0x19, 0x98, 0x6c, 0x09, 0xed, 0x09, 0x2b, 0x5f, 0xb3, 0xd6, 0xed,
	0x70, 0xb0, 0x7f, 0xfa, 0xc1, 0x39, 0xa8, 0xf1, 0xf2, 0x3c, 0x3d, 0x48, 0x8c, 0x5c, 0x5c, 0x59,
	0x7b, 0x37, 0x66, 0x3d, 0x8d, 0xe2, 0xf9, 0x9c, 0xec, 0x2f, 0xfd, 0x21, 0x6f, 0x65, 0x16, 0xca,
	0xfe, 0x95, 0x8a, 0x4b, 0x08, 0xe2, 0x44, 0xc5, 0xde, 0x70, 0x00, 0x87, 0xc7, 0x97, 0xa8, 0x17,
	0x3f, 0x61, 0xa6, 0xa7, 0x4f, 0x0c, 0xa8, 0xdc, 0xd3, 0x13, 0x86, 0x5e, 0x42, 0x2c, 0xb9, 0x1c,
	0x01, 0xe8, 0xda, 0xac, 0x4a, 0x78, 0xff, 0xc8, 0xd6, 0x53, 0x7b, 0x8a, 0xbf, 0x73, 0x2e, 0xa4,
	0x50, 0xa8, 0x53, 0x96, 0x9d, 0x42, 0xae, 0x6d, 0x69, 0x29, 0x8d, 0x63, 0x5b, 0xbc, 0x3d, 0x30,
	0x81, 0x85, 0xb0, 0x44, 0x44, 0xf9, 0x32, 0x3c, 0x2b, 0xc8, 0x46, 0xab, 0x44, 0x5b, 0xcb, 0x42,
	0x50, 0x11, 0xb2, 0x11, 0x86, 0x7f, 0x5e, 0x64, 0x0b, 0x09, 0xe7, 0x95, 0x5d, 0xc6, 0x3b, 0x6d,
	0xac, 0xe7, 0x39, 0xf6, 0xa4, 0x29, 0x27, 0xf8, 0x0a, 0x16, 0x0e, 0x6c, 0x4d, 0x5f, 0x6f, 0xe2,
	0x54, 0xf7, 0x9b, 0x71, 0xbb, 0xb3, 0x5e, 0xfd, 0x28, 0xf7, 0xcf, 0x29, 0xc3, 0xcf, 0x16, 0xb2,
	0xcd, 0x7c, 0x23, 0xf7, 0x2f, 0xfe, 0x81, 0x24, 0xab, 0xe2, 0x09, 0x54, 0x03, 0x87, 0x41, 0x63,
	0x7d, 0xde, 0x5b, 0x89, 0x88, 0xf3, 0x21, 0x71, 0x8c, 0xcf, 0xd4, 0xbb, 0x09, 0x97, 0x52, 0xcf,
	0x93, 0xee, 0x90, 0xe0, 0x6b, 0xe8, 0x3e, 0x5a, 0x2a, 0x06, 0x84, 0xdc, 0x2a, 0x8c, 0xea, 0x71,
	0x7e, 0xa5, 0x57, 0x75, 0x8f, 0x7f, 0x3b, 0xff, 0x2f, 0x4a, 0xeb, 0x42, 0x65, 0x0d, 0x18, 0x75,
	0x2b, 0xb6, 0x44, 0x3d, 0x02, 0xde, 0x9e, 0xe3, 0x1e, 0x50, 0xe6, 0x2a, 0x30, 0x31, 0x65, 0x84,
	0x45, 0x6a, 0x26, 0x77, 0xd2, 0x91, 0x94, 0xc7, 0x04, 0xb5, 0x98, 0x7e, 0x69, 0x6d, 0xee, 0xd9,
	0xef, 0xbc, 0x80, 0x84, 0x53, 0x3a, 0xcc, 0x56, 0x45, 0x15, 0x46, 0xec, 0x92, 0x0a, 0x41, 0x25,
	0x21, 0x6d, 0x28, 0x1e, 0xa2, 0x8a, 0x03, 0xb2, 0x58, 0x4c, 0x36, 0x84, 0x2f, 0xb9, 0xd3, 0x2d,
	0xe3, 0x5d, 0x7f, 0xbc, 0x57, 0x05, 0x15, 0x3c, 0x85, 0xec, 0x5c, 0xd0, 0xf0, 0x9c, 0x1e, 0xe7,
	0xe5, 0x1a, 0x58, 0xac, 0x39, 0x82, 0x15, 0x03, 0x98, 0x29, 0x4b, 0x2a, 0x4f, 0xd4, 0xf4, 0x8d,
	0x0a, 0xa7, 0xf9, 0x23, 0x2f, 0xab, 0xd2, 0xaf, 0x6b, 0xa3, 0x4e, 0x7b, 0xd7, 0xba, 0x55, 0x9d,
	0xe8, 0x38, 0x52, 0x23, 0x0c, 0xb2, 0x58, 0x87, 0x4c, 0xc8, 0xf0, 0x20, 0xd9, 0xca, 0xee, 0x96,
	0x5d, 0x6c, 0x40, 0x46, 0x8e, 0x98, 0x8e, 0x92, 0xbe, 0xe5, 0x49, 0xfb, 0xd4, 0x0b, 0x91, 0xfb,
	0x2a, 0xad, 0xdf, 0x90, 0x0e, 0xef, 0x11, 0xd3, 0x6a, 0x06, 0x91, 0x0e, 0xaf, 0x83, 0xe1, 0xf0,
	0xb6, 0xd6, 0xca, 0x49, 0x55, 0x78, 0x1b, 0x94, 0x91, 0x7e, 0xf5, 0x71, 0x90, 0xe5, 0xe4, 0x41,
	0x7e, 0x7a, 0x8a, 0xbb, 0x17, 0x08, 0xc2, 0x86, 0xbb, 0x1e, 0x18, 0x96, 0xa7, 0x63, 0x60, 0x95,
	0xec, 0xf7, 0xf5, 0x01, 0x7a, 0xec, 0x3f, 0x50, 0xde, 0x8f, 0xb9, 0x35, 0x08, 0xa2, 0x48, 0x51,
	0xad, 0x6c, 0xc7, 0x7e, 0xf3, 0xb7, 0xcf, 0x3e, 0x5c, 0x04, 0xbf, 0x51, 0xf9, 0x7e, 0x0a, 0x25,
	0xab, 0x54, 0x07, 0x65, 0x6c, 0x9d, 0x0d, 0x46, 0x60, 0x08, 0xa7, 0x1a, 0x86, 0xe5, 0x50, 0xfc,
	0x30, 0xae, 0xd6, 0x50, 0x69, 0x5a, 0xcc, 0xee, 0xf8, 0x26, 0xc8, 0xcb, 0xa7, 0xfb, 0x41, 0xca,
	0x3d, 0x6f, 0x97, 0xfd, 0x7a, 0x59, 0x82, 0xc8, 0xb7, 0x95, 0x3d, 0xf6, 0x40, 0xcc, 0x3b, 0xbb,
	0xe3, 0xe3, 0xff, 0xbb, 0x49, 0x47, 0x58, 0x49, 0x4c, 0xfb, 0x9b, 0x8d, 0x85, 0x27, 0x72, 0x86,
	0x17, 0x1c, 0xb3, 0xbf, 0x33, 0x8c, 0x91, 0x0b, 0x43, 0xcd, 0x81, 0x84, 0x11, 0x4e, 0x8f, 0x41,
	0x4f, 0x63, 0x87, 0x3a, 0x63, 0xce, 0x69, 0xc4, 0xfe, 0x00, 0x7a, 0x4e, 0xf3, 0x7d, 0xcc, 0x26,
	0xfe, 0x70, 0xfa, 0xe8, 0x19, 0x9b, 0xf4, 0x73, 0x72, 0x35, 0x3d, 0x7c, 0x99, 0x67, 0x9e, 0xa4,
	0xd4, 0x73, 0x1c, 0xdc, 0xe6, 0x61, 0x0f, 0xe4, 0xdc, 0xdc, 0x81, 0xe6, 0x1b, 0x76, 0x9d, 0x2d,
	0xcb, 0xbb, 0x9f, 0xd1, 0x90, 0x53, 0x4c, 0x92, 0xba, 0xa6, 0xb2, 0x49, 0xc8, 0xb0, 0x1c, 0x6c,
	0x9e, 0xb0,
};

HRESULT VS_Direct3D10Render::InitInputAssemplyStage()
{
	HRESULT hr = D3DERR_INVALIDDEVICE;

	VS_Container cnt;
	char *pBuffShader = 0;
	unsigned long nBuffLen = 0;
	size_t sz=0;

#if 0
	char *pb = 0;
	unsigned char *pbcnt = 0;
	unsigned long size = 0;
	fpos_t pos0, pos1;
	const char name_[] = "vp_processing_frame_i420";
	FILE *f = fopen("processing.fx", "rb");

	fgetpos(f, &pos0);
	fseek(f, 0, SEEK_END);
	fgetpos(f, &pos1);
	unsigned long len = (unsigned long)(pos1 - pos0);
	fseek(f, 0, SEEK_SET);
	pb = (char*)malloc(len);
	fread(pb, len, 1, f);
	fclose(f);

	cnt.AddValue(name_, pb, len);
	cnt.SerializeAlloc((void*&)pbcnt, size);
	free(pb);
	len = 0;
	f = fopen("bin.psh", "wb");
	for (int i = 0; i < size; i++) {
		if (i % 16 == 0) fprintf(f, "\n");
		fprintf(f, "0x%2.2x, ", pbcnt[i]);
	}
	fclose(f);
#else
	unsigned char *pResampler = fx_processing_frame_i420;
	int sizeBuff = sizeof(fx_processing_frame_i420);

	if (!cnt.Deserialize(pResampler, sizeBuff)) {
		DTRACE(VSTM_VRND, "failed deserialize fx");
		sprintf(m_cError, "failed deserialize fx\n");
		return E_FAIL;
	}
	if (!cnt.GetValue("vp_processing_frame_i420", (void*)(pBuffShader), sz)) {
		pBuffShader = (char*)malloc(sz);
		if (!cnt.GetValue("vp_processing_frame_i420", (void*)(pBuffShader), sz)) {
			DTRACE(VSTM_VRND, "failed load fx");
			sprintf(m_cError, "failed load fx\n");
			return E_FAIL;
		}
	}
	nBuffLen = sz;

	ID3D10Blob *pErrors = 0;

#if 0

	hr = D3DX10CreateEffectFromFile("processing.fx", 0, 0, "fx_4_0", D3D10_SHADER_ENABLE_STRICTNESS | D3D10_SHADER_OPTIMIZATION_LEVEL3,
										 0, m_pDeviceD3D10, 0, 0, &m_pEffect, &pErrors, 0);
	if (FAILED(hr)) {
		char *pC = (char*)pErrors->GetBufferPointer();
		if (pBuffShader) free(pBuffShader);
		pErrors->Release();
		return hr;
	}
	if (pErrors) pErrors->Release(); pErrors = 0;

#else

	ID3D10Blob *pCompiliedEffect = 0;
	hr = g_D3D10CompileEffectFromMemory(pBuffShader, nBuffLen, 0, 0, 0, D3D10_SHADER_ENABLE_STRICTNESS | D3D10_SHADER_OPTIMIZATION_LEVEL3, 0, &pCompiliedEffect, &pErrors);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed compilied fx");
		sprintf(m_cError, "failed compilied fx\n");
		if (pBuffShader) free(pBuffShader);
		pErrors->Release();
		return hr;
	}
	if (pErrors) pErrors->Release(); pErrors = 0;
	hr = g_D3D10CreateEffectFromMemory(pCompiliedEffect->GetBufferPointer(), pCompiliedEffect->GetBufferSize(), 0, m_pDeviceD3D10, 0, &m_pEffect);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create fx");
		sprintf(m_cError, "failed create fx\n");
		if (pBuffShader) free(pBuffShader);
		pCompiliedEffect->Release();
		return hr;
	}
	if (pErrors) pErrors->Release(); pErrors = 0;
	pCompiliedEffect->Release();

#endif

	m_pTechnique = m_pEffect->GetTechniqueByName("vp_processing_frame_i420");
	if ( SUCCEEDED(hr) ) {
		/// create effect pointers
		m_pEffectVar[SATURATE]		= m_pEffect->GetVariableByName("dwSaturation")->AsScalar();
		m_pEffectVarVect[TEXEL05]	= m_pEffect->GetVariableByName("texelSize05")->AsVector();
		m_pEffectVarVect[TEXEL]		= m_pEffect->GetVariableByName("texelSize")->AsVector();
		m_pEffectVarVect[TEXELU]	= m_pEffect->GetVariableByName("texelSizeU")->AsVector();
		m_pEffectVarVect[TEXELV]	= m_pEffect->GetVariableByName("texelSizeV")->AsVector();
		m_pEffectVarVect[IMAGESIZE]	= m_pEffect->GetVariableByName("imageSize")->AsVector();
		/// create shader resources
		m_pShaderResource[MAIN]				= m_pEffect->GetVariableByName("tex2D")->AsShaderResource();
		m_pShaderResource[YUV444_P0]		= m_pEffect->GetVariableByName("tex2D_0")->AsShaderResource();
		m_pShaderResource[YUV444_P1]		= m_pEffect->GetVariableByName("tex2D_1")->AsShaderResource();
		m_pShaderResource[YUV444_P2]		= m_pEffect->GetVariableByName("tex2D_2")->AsShaderResource();
		/// define input layout
		D3D10_INPUT_ELEMENT_DESC layout[] =
		{
			{"POSITION", 0,		DXGI_FORMAT_R32G32B32_FLOAT, 0,	 0, D3D10_INPUT_PER_VERTEX_DATA, 0},
			{	"COLOR", 0,	 DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D10_INPUT_PER_VERTEX_DATA, 0},
			{"TEXCOORD", 0,		   DXGI_FORMAT_R32G32_FLOAT, 0, 28, D3D10_INPUT_PER_VERTEX_DATA, 0}
		};
		unsigned int numElements = sizeof(layout) / sizeof(layout[0]);
		/// create input layout
		D3D10_PASS_DESC PassDesc;
		m_pTechnique->GetPassByIndex(0)->GetDesc(&PassDesc);
		hr = m_pDeviceD3D10->CreateInputLayout(layout, numElements, PassDesc.pIAInputSignature, PassDesc.IAInputSignatureSize, &m_pVertexLayout);
		if ( SUCCEEDED(hr) ) {
			/// Set the input layout
			m_pDeviceD3D10->IASetInputLayout(m_pVertexLayout);
		} else {
			DTRACE(VSTM_VRND, "failed create input layout");
			sprintf(m_cError, "failed create input layout\n");
		}
	} else {
		DTRACE(VSTM_VRND, "failed create technique from fx");
		sprintf(m_cError, "failed create technique from fx\n");
	}

#endif

	if (pBuffShader) free(pBuffShader);

	return hr;
}

HRESULT VS_Direct3D10Render::InitRasterizerStage()
{
	HRESULT hr;

	D3D10_RASTERIZER_DESC rasterizerState;
	rasterizerState.CullMode = D3D10_CULL_NONE;
	rasterizerState.FillMode = D3D10_FILL_SOLID;
	rasterizerState.FrontCounterClockwise = true;
    rasterizerState.DepthBias = false;
    rasterizerState.DepthBiasClamp = 0;
    rasterizerState.SlopeScaledDepthBias = 0;
    rasterizerState.DepthClipEnable = true;
    rasterizerState.ScissorEnable = false;
    rasterizerState.MultisampleEnable = false;
    rasterizerState.AntialiasedLineEnable = false;
	hr = m_pDeviceD3D10->CreateRasterizerState(&rasterizerState, &m_pRS);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create rasterizer state");
		sprintf(m_cError, "failed create rasterizer state\n");
		return hr;
	}
	m_pDeviceD3D10->RSSetState(m_pRS);

	return hr;
}

HRESULT VS_Direct3D10Render::InitSceneVariables()
{
	HRESULT hr;

	unsigned int numVertices = 100;
	D3D10_BUFFER_DESC bd;
	bd.Usage = D3D10_USAGE_DYNAMIC;
	bd.ByteWidth = sizeof(vertex) * numVertices;
	bd.BindFlags = D3D10_BIND_VERTEX_BUFFER;
	bd.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE;
	bd.MiscFlags = 0;
	hr = m_pDeviceD3D10->CreateBuffer(&bd, NULL, &m_pVertexBuffer);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create vertex buffer");
		sprintf(m_cError, "failed create vertex buffer\n");
		return hr;
	}
	/// set vertex buffer
	unsigned int stride = sizeof(vertex);
	unsigned int offset = 0;
	m_pDeviceD3D10->IASetVertexBuffers(0, 1, &m_pVertexBuffer, &stride, &offset);
	///
	m_pDeviceD3D10->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
	/// inin blend state
	D3D10_BLEND_DESC BlendState;
	ZeroMemory(&BlendState, sizeof(D3D10_BLEND_DESC));
	BlendState.AlphaToCoverageEnable = FALSE;
	BlendState.BlendEnable[0] = TRUE;
	BlendState.SrcBlend = D3D10_BLEND_SRC_ALPHA;
	BlendState.DestBlend = D3D10_BLEND_INV_SRC_ALPHA;
	BlendState.BlendOp = D3D10_BLEND_OP_ADD;
	BlendState.SrcBlendAlpha = D3D10_BLEND_ZERO;
	BlendState.DestBlendAlpha = D3D10_BLEND_ZERO;
	BlendState.BlendOpAlpha = D3D10_BLEND_OP_ADD;
	BlendState.RenderTargetWriteMask[0] = D3D10_COLOR_WRITE_ENABLE_ALL;
	hr = m_pDeviceD3D10->CreateBlendState(&BlendState, &m_pBlendState);
	if (FAILED(hr)) {
		DTRACE(VSTM_VRND, "failed create blend state");
		sprintf(m_cError, "failed create blend state\n");
	}

	return hr;
}

HRESULT VS_Direct3D10Render::CreateDevice(HWND hwnd, int width, int height)
{
	HRESULT hr = D3D_OK;

	ReleaseDevice();
	///------------ create device
	hr = CreateDevice3D(hwnd, width, height);
	if (FAILED(hr)) return hr;
	///------------ input assembly stage
	hr = InitInputAssemplyStage();
	if (FAILED(hr)) return hr;
	///------------ rasterizer stage
	hr = InitRasterizerStage();
	if (FAILED(hr)) return hr;
	/// setup up scene variables
	hr = InitSceneVariables();

	return hr;
}

HRESULT VS_Direct3D10Render::ResetSwapChain(HWND hwnd, int back_buffer_width, int back_buffer_height, int width, int height)
{
	HRESULT hr = D3D_OK;

	DeleteTextures();

	if (hwnd == m_hwnd) {
		hr = m_pSwapChain->ResizeBuffers(1, back_buffer_width, back_buffer_height, DXGI_FORMAT_R8G8B8A8_UNORM, 0);
		if (FAILED(hr)) {
			DTRACE(VSTM_VRND, "failed reset SwapChain: resize buffers");
			return hr;
		}
	} else {
		DXGI_SWAP_CHAIN_DESC sd;
		m_pSwapChain->GetDesc(&sd);
		m_pSwapChain->Release(); m_pSwapChain = 0;
		sd.OutputWindow = hwnd;
		sd.BufferDesc.Width = back_buffer_width;
		sd.BufferDesc.Height = back_buffer_height;
		hr = m_pDXGIFactory->CreateSwapChain(m_pDXGIDevice, &sd, &m_pSwapChain);
		if (FAILED(hr)) {
			DTRACE(VSTM_VRND, "failed reset SwapChain: recreate");
			return hr;
		}
	}

	hr = AllocTextures(width, height);

	return hr;
}

bool VS_Direct3D10Render::PrepareFrame(HWND hwnd)
{
	HRESULT hRet = D3D_OK;
	bool sucs = true;

	if (m_bNewFrame) {
		if (m_dwVRUse & VR_USE_CONVIN) if (!ConvertColorSpaceIn()) return false;
		if (m_dwVRUse & VR_USE_FLIP) if (!MirrorVertical()) return false;
		/// load i420 texture
		D3D10_TEXTURE2D_DESC desc;
		m_pTexture[I420]->GetDesc(&desc);
		D3D10_MAPPED_TEXTURE2D mappedTex;
		hRet = m_pTexture[I420]->Map(0, D3D10_MAP_WRITE_DISCARD, 0, &mappedTex);
		if (SUCCEEDED(hRet)) {
			int i;
			RECT rect(m_rPic2);
			unsigned char *pSrcBuff = m_pBufferMirrorIn;
			unsigned char *pDstBuff = (unsigned char*)mappedTex.pData;
			for (i = 0; i < rect.bottom; i++) {
				memcpy(pDstBuff, pSrcBuff, rect.right);
				pDstBuff += mappedTex.RowPitch;
				pSrcBuff += rect.right;
			}
			rect.right >>= 1;
			for (i = 0; i < rect.bottom; i++) {
				memcpy(pDstBuff, pSrcBuff, rect.right); memset(pDstBuff + rect.right, 0x80, 2);
				pDstBuff += mappedTex.RowPitch;
				pSrcBuff += rect.right;
			}
			m_pTexture[I420]->Unmap(0);
			sucs = true;
		}
		CreateTextureName(m_rViewAreaPrev.right - m_rViewAreaPrev.left, m_rViewAreaPrev.bottom - m_rViewAreaPrev.top);
		m_bNewFrame = FALSE;
	}
	return sucs;
}

void VS_Direct3D10Render::SetViewports(int TopLeftX, int TopLeftY, int width, int height)
{
	D3D10_VIEWPORT vp;
	vp.TopLeftX = TopLeftX;
	vp.TopLeftY = TopLeftY;
	vp.Width    = width;
	vp.Height   = height;
	vp.MinDepth = 0.0f;
	vp.MaxDepth = 1.0f;
	m_pDeviceD3D10->RSSetViewports(1, &vp);
}

HRESULT VS_Direct3D10Render::SetVertexBuffer(float tex_u0, float tex_u1, float tex_v0, float tex_v1)
{
	vertex* v = NULL;
	HRESULT hr = m_pVertexBuffer->Map(D3D10_MAP_WRITE_DISCARD, 0, (void**) &v );
	if (SUCCEEDED(hr)) {
		m_numVertices = 4;
		v[0] = vertex(D3DXVECTOR3(-1,-1, 0), D3DXVECTOR4( 1, 0, 0, 1), D3DXVECTOR2(tex_u0, tex_v1));
		v[1] = vertex(D3DXVECTOR3(-1, 1, 0), D3DXVECTOR4( 0, 1, 0, 1), D3DXVECTOR2(tex_u0, tex_v0));
		v[2] = vertex(D3DXVECTOR3( 1,-1, 0), D3DXVECTOR4( 0, 0, 1, 1), D3DXVECTOR2(tex_u1, tex_v1));
		v[3] = vertex(D3DXVECTOR3( 1, 1, 0), D3DXVECTOR4( 1, 1, 0, 1), D3DXVECTOR2(tex_u1, tex_v0));
		m_pVertexBuffer->Unmap();
	}
	return hr;
}

HRESULT VS_Direct3D10Render::ConvertI420toYUV444()
{
	HRESULT hr = D3DERR_DRIVERINTERNALERROR;

	float coordTex[3][4] =
	{
		{0.0f, 1.0f,  0.0f,  0.5f},
		{0.0f, 0.5f,  0.5f, 0.75f},
		{0.0f, 0.5f, 0.75f,  1.0f}
	};

	hr = m_pShaderResource[MAIN]->SetResource(m_pShaderResView[I420]);

	for (int i = 0; i < 3; i++) {
		m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[YUV444_P0+i], NULL);
		D3D10_TEXTURE2D_DESC td;
		m_pTexture[YUV444_P0+i]->GetDesc(&td);
		SetViewports(0, 0, td.Width, td.Height);
		hr |= SetVertexBuffer(coordTex[i][0], coordTex[i][1], coordTex[i][2], coordTex[i][3]);
		hr |= m_pTechnique->GetPassByName("linear_sampling")->Apply(0);
		m_pDeviceD3D10->Draw(m_numVertices, 0);
	}

	return hr;
}

HRESULT VS_Direct3D10Render::ConvertYUV444toRGBA(int saturation)
{
	HRESULT hr = D3DERR_DRIVERINTERNALERROR;

	m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[RGBA], NULL);
	D3D10_TEXTURE2D_DESC td;
	m_pTexture[RGBA]->GetDesc(&td);
	SetViewports(0, 0, td.Width, td.Height);
	hr = SetVertexBuffer(0.0f, 1.0f, 0.0f, 1.0f);
	hr |= m_pEffectVar[SATURATE]->SetFloat((float)saturation/100.0f);
	hr |= m_pTechnique->GetPassByName("yuv444_to_rgba")->Apply(0);
	m_pDeviceD3D10->Draw(m_numVertices, 0);

	return hr;
}

HRESULT VS_Direct3D10Render::CopyRGBA()
{
	HRESULT hr = D3DERR_DRIVERINTERNALERROR;

	m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[MAIN], NULL);
	SetViewports(m_rDstSci.left, m_rDstSci.top, m_rDstVid.right, m_rDstVid.bottom);
	hr = SetVertexBuffer(0.0f, 1.0f, 0.0f, 1.0f);
	hr |= m_pShaderResource[MAIN]->SetResource(m_pShaderResView[RGBA]);
	hr |= m_pTechnique->GetPassByName("point_sampling")->Apply(0);
	m_pDeviceD3D10->Draw(m_numVertices, 0);

	return hr;
}

HRESULT VS_Direct3D10Render::ResamplingRGBA()
{
	HRESULT hr = D3DERR_DRIVERINTERNALERROR;

	float EffectBicubicVars[6] = {0};
	float *pEffectBuff = EffectBicubicVars;

	/// resampling on X
	m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[RESAMPLE_W], NULL);
	D3D10_TEXTURE2D_DESC td, tdn;
	m_pTexture[RGBA]->GetDesc(&td);
	m_pTexture[RESAMPLE_W]->GetDesc(&tdn);
	SetViewports(0, 0, tdn.Width, td.Height);
	hr = SetVertexBuffer(0.0f, (float)td.Width, 0.0f, (float)td.Height);
	EffectBicubicVars[0] = 0.5f / (float)td.Width;
	EffectBicubicVars[1] = 0.5f / (float)td.Height;
	EffectBicubicVars[2] = 1.0f / (float)td.Width;
	EffectBicubicVars[3] = 1.0f / (float)td.Height;
	EffectBicubicVars[4] = 1.0f / (float)td.Width;
	EffectBicubicVars[5] = 0.0f;
	hr |= m_pEffectVarVect[TEXEL05]->SetFloatVector(pEffectBuff);
	hr |= m_pEffectVarVect[TEXEL]->SetFloatVector(pEffectBuff+2);
	hr |= m_pEffectVarVect[TEXELU]->SetFloatVector(pEffectBuff+4);
	hr |= m_pShaderResource[MAIN]->SetResource(m_pShaderResView[RGBA]);
	hr |= m_pTechnique->GetPassByName("resampler_bicubic_x")->Apply(0);
	m_pDeviceD3D10->Draw(m_numVertices, 0);

	/// resampling on Y
	m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[MAIN], NULL);
	SetViewports(m_rDstSci.left, m_rDstSci.top, m_rDstVid.right, m_rDstVid.bottom);
	m_pTexture[RESAMPLE_W]->GetDesc(&td);
	hr = SetVertexBuffer(0.0f, (float)td.Width, 0.0f, (float)td.Height);
	EffectBicubicVars[0] = 0.5f / (float)td.Width;
	EffectBicubicVars[1] = 0.5f / (float)td.Height;
	EffectBicubicVars[2] = 1.0f / (float)td.Width;
	EffectBicubicVars[3] = 1.0f / (float)td.Height;
	EffectBicubicVars[4] = 0.0f;
	EffectBicubicVars[5] = 1.0f / (float)td.Height;
	hr |= m_pEffectVarVect[TEXEL05]->SetFloatVector(pEffectBuff);
	hr |= m_pEffectVarVect[TEXEL]->SetFloatVector(pEffectBuff+2);
	hr |= m_pEffectVarVect[TEXELV]->SetFloatVector(pEffectBuff+4);
	hr |= m_pShaderResource[MAIN]->SetResource(m_pShaderResView[RESAMPLE_W]);
	hr |= m_pTechnique->GetPassByName("resampler_bicubic_y")->Apply(0);
	m_pDeviceD3D10->Draw(m_numVertices, 0);

	return hr;
}

HRESULT VS_Direct3D10Render::DrawDisplayName()
{
	HRESULT hr = D3DERR_DRIVERINTERNALERROR;

	m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[MAIN], NULL);
	m_pDeviceD3D10->OMSetBlendState(m_pBlendState, 0, 0xffffffff);
	SetViewports(0, 0, m_DisplayName.rName.right, m_DisplayName.rName.bottom);
	hr = SetVertexBuffer(0.0f, 1.0f, 0.0f, 1.0f);
	hr |= m_pShaderResource[MAIN]->SetResource(m_pShaderResView[DISPLAY_NAME]);
	hr |= m_pTechnique->GetPassByName("point_sampling")->Apply(0);
	m_pDeviceD3D10->Draw(m_numVertices, 0);
	m_pDeviceD3D10->OMSetBlendState(0, 0, 0xffffffff);

	return hr;
}

HRESULT VS_Direct3D10Render::DrawDisplayLogo()
{
	HRESULT hr = D3DERR_DRIVERINTERNALERROR;

	m_pDeviceD3D10->OMSetRenderTargets(1, &m_pRenderTarget[MAIN], NULL);
	m_pDeviceD3D10->OMSetBlendState(m_pBlendState, 0, 0xffffffff);
	SetViewports(m_DisplayLogo.rName.left, m_DisplayLogo.rName.top, m_DisplayLogo.width, m_DisplayLogo.height);
	hr = SetVertexBuffer(0.0f, 1.0f, 0.0f, 1.0f);
	hr |= m_pShaderResource[MAIN]->SetResource(m_pShaderResView[DISPLAY_LOGO]);
	hr |= m_pTechnique->GetPassByName("point_sampling")->Apply(0);
	m_pDeviceD3D10->Draw(m_numVertices, 0);
	m_pDeviceD3D10->OMSetBlendState(0, 0, 0xffffffff);

	return hr;
}

int VS_Direct3D10Render::DrawFrame(HWND hwnd)
{
	VS_AutoLock lock(this);

	//AUTO_PROF

	if (!IsInited())
		return 1;

	if (m_DrawBorders)
		DrawBorders();

	if (!m_IsValid) { // try to repair if render cannot draw
		DWORD currTime = timeGetTime();
		if (currTime - m_repairTime >= VR_REPAIR_TIME) {
			m_repairTime = currTime;
			SetMode(VRM_DEFAULT, hwnd);
		}
		if (!m_IsValid) return 1;
	}

	if (hwnd != m_hwnd || m_bForceBicubicChange != m_bForceBicubic) {
		m_RenderMode = VRM_UNDEF;
		m_bForceBicubicChange = m_bForceBicubic;
		if (SetMode(VRM_DEFAULT, hwnd)) return 1;
	}

	HRESULT hRet;

	if (!SetRectangle(hwnd)) return 1;

	if (!IsWindowVisible(m_hwnd)) return 0;

	if (!PrepareFrame(hwnd)) return 1;

	hRet = ConvertI420toYUV444();
	hRet |= ConvertYUV444toRGBA(m_dwSaturation);

	if (!EqualRect(&m_rDstVid, &m_rPic2)) {
		hRet |= ResamplingRGBA();
	} else {
		hRet |= CopyRGBA();
	}

	if (!IsRectEmpty(&m_DisplayName.rName)) {
		hRet |= DrawDisplayName();
	}

	if (!IsRectEmpty(&m_DisplayLogo.rName)) {
		hRet |= DrawDisplayLogo();
	}

	hRet |= m_pSwapChain->Present(0, 0);

	return hRet != D3D_OK;
}

int VS_Direct3D10Render::CreateTextureLogo(int w, int h)
{
	if (!m_bDrawLogo) {
		SetRectEmpty(&m_DisplayLogo.rName);
		return -1;
	}

	FILE* file = fopen("trgb.bmp", "rb");

	if (file != 0) {
		BITMAPFILEHEADER bmf;
		BITMAPINFOHEADER bmi;
		fread(&bmf, sizeof(bmf), 1, file);
		fread(&bmi, sizeof(bmi), 1, file);
		bmi.biSizeImage = bmi.biHeight * bmi.biWidth * bmi.biBitCount / 8;
		fseek(file, bmf.bfOffBits, SEEK_SET);

		if (bmi.biBitCount == 32) {
			unsigned char *imgLogo = new unsigned char [bmi.biSizeImage];
			fread(imgLogo, bmi.biSizeImage, 1, file);
			fclose(file);

			/// resampling
			unsigned int width = (w / 5 + 1) &~ 1;
			unsigned int height = (h / 5 + 1) &~ 1;
			unsigned char *imgRsmplLogo = new unsigned char [width * height * bmi.biBitCount / 8];
			VS_VideoProc vproc;
			vproc.ResampleRGB32(imgLogo, imgRsmplLogo, bmi.biWidth, bmi.biHeight, width, height, width * bmi.biBitCount / 8);
			///

			HRESULT hr;
			if (m_pTexture[DISPLAY_LOGO]) m_pTexture[DISPLAY_LOGO]->Release(); m_pTexture[DISPLAY_LOGO] = 0;
			if (m_pShaderResView[DISPLAY_LOGO]) m_pShaderResView[DISPLAY_LOGO]->Release(); m_pShaderResView[DISPLAY_LOGO] = 0;
			D3D10_TEXTURE2D_DESC td;
			td.Width              = width;
			td.Height             = height;
			td.MipLevels          = 1;
			td.ArraySize          = 1;
			td.Format             = DXGI_FORMAT_R8G8B8A8_UNORM;
			td.SampleDesc.Count   = 1;
			td.SampleDesc.Quality = 0;
			td.Usage              = D3D10_USAGE_DYNAMIC;
			td.BindFlags          = D3D10_BIND_SHADER_RESOURCE;
			td.CPUAccessFlags     = D3D10_CPU_ACCESS_WRITE;
			td.MiscFlags          = 0;
			hr = m_pDeviceD3D10->CreateTexture2D(&td, 0, &m_pTexture[DISPLAY_LOGO]);
			if ( SUCCEEDED(hr) ) {
				D3D10_SHADER_RESOURCE_VIEW_DESC srd;
				srd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				srd.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
				srd.Texture2D.MostDetailedMip = 0;
				srd.Texture2D.MipLevels = 1;
				hr = m_pDeviceD3D10->CreateShaderResourceView(m_pTexture[DISPLAY_LOGO], &srd, &m_pShaderResView[DISPLAY_LOGO]);
				if ( SUCCEEDED(hr) ) {
					D3D10_MAPPED_TEXTURE2D mappedTex;
					hr = m_pTexture[DISPLAY_LOGO]->Map(0, D3D10_MAP_WRITE_DISCARD, 0, &mappedTex);
					if ( SUCCEEDED(hr) ) {
						unsigned int i, j;
						unsigned int *pTexture = (unsigned int*)mappedTex.pData;
						unsigned int *pSrc = (unsigned int*)imgRsmplLogo + width * (height - 1);
						for (i = 0; i < height; i++) {
							for (j = 0; j < width; j++) {
								pTexture[j] = pSrc[width - j - 1];
							}
							//memcpy(pTexture, pSrc, width * sizeof(unsigned int));
							pTexture += mappedTex.RowPitch / 4;
							pSrc -= width;
						}
						m_pTexture[DISPLAY_LOGO]->Unmap(0);
					}
				}
			}

			delete [] imgLogo;
			delete [] imgRsmplLogo;

			m_DisplayLogo.width = width;
			m_DisplayLogo.height = height;
			SetRect(&m_DisplayLogo.rName, w - width, h - height, w, h);
		}
	}

	return 0;
}

int VS_Direct3D10Render::CreateTextureName(int w, int h)
{
	if (m_DisplayName.name.empty() || w <= 0 || h <= 0) {
		SetRectEmpty(&m_DisplayName.rName);
		return -1;
	}

	int ow, oh;
	ow = m_DisplayName.width;
	oh = m_DisplayName.height;
	m_DisplayName.width = w;
	m_DisplayName.height = h / 16;
	if (m_DisplayName.height < 13) m_DisplayName.height = 13;
	int htxt = m_DisplayName.height;
	m_DisplayName.height = (m_DisplayName.height + 1)&~1;

	if (ow != m_DisplayName.width || oh != m_DisplayName.height || m_pTexture[DISPLAY_NAME] == NULL || m_DisplayName.update) {
		SetRectEmpty(&m_DisplayName.rName);

		SIZE sizeText;
		HDC hDC = GetDC(NULL);
		HDC myDc = CreateCompatibleDC(hDC);
		HBITMAP bmap = CreateCompatibleBitmap(hDC, m_DisplayName.width, m_DisplayName.height);
		SelectObject(myDc, bmap);

		HFONT hFont = CreateFontW(htxt, 0, 0, 0, FW_LIGHT, 0, 0, 0,
								  DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
								  FF_SWISS|VARIABLE_PITCH, L"Tahoma\0");
		if (hFont) {
			SelectObject(myDc, hFont);
			GetTextExtentPoint32W(myDc, m_DisplayName.name.data(), m_DisplayName.name.length(), &sizeText);

			RECT rect;
			SetRect(&rect, 0, 0, m_DisplayName.width, m_DisplayName.height);
			SetBkColor(myDc, D3D_BCKGR_COLOR);
			HBRUSH hbr = CreateSolidBrush(D3D_BCKGR_COLOR);
			FillRect(myDc, &rect, hbr);
			SetTextColor(myDc, D3D_TEXT_COLOR);
			DrawTextW(myDc, m_DisplayName.name.data(), m_DisplayName.name.length(), &rect, DT_CENTER | DT_END_ELLIPSIS | DT_NOPREFIX);

			auto text_data = std::make_unique<unsigned char[]>(m_DisplayName.width * m_DisplayName.height * 4);

			BITMAPINFO bmi;
			memset(&bmi.bmiHeader, 0, sizeof(BITMAPINFOHEADER));
			bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
			bmi.bmiHeader.biBitCount = 32;
			bmi.bmiHeader.biHeight = m_DisplayName.height;
			bmi.bmiHeader.biPlanes = 1;
			bmi.bmiHeader.biWidth = m_DisplayName.width;
			bmi.bmiHeader.biSizeImage = m_DisplayName.width * m_DisplayName.height * 4;

			GetDIBits(myDc, bmap, 0, m_DisplayName.height, text_data.get(), &bmi, DIB_RGB_COLORS);

			HRESULT hr;
			if (m_pTexture[DISPLAY_NAME]) m_pTexture[DISPLAY_NAME]->Release(); m_pTexture[DISPLAY_NAME] = 0;
			if (m_pShaderResView[DISPLAY_NAME]) m_pShaderResView[DISPLAY_NAME]->Release(); m_pShaderResView[DISPLAY_NAME] = 0;

			D3D10_TEXTURE2D_DESC td;
			td.Width              = m_DisplayName.width;
			td.Height             = m_DisplayName.height;
			td.MipLevels          = 1;
			td.ArraySize          = 1;
			td.Format             = DXGI_FORMAT_R8G8B8A8_UNORM;
			td.SampleDesc.Count   = 1;
			td.SampleDesc.Quality = 0;
			td.Usage              = D3D10_USAGE_DYNAMIC;
			td.BindFlags          = D3D10_BIND_SHADER_RESOURCE;
			td.CPUAccessFlags     = D3D10_CPU_ACCESS_WRITE;
			td.MiscFlags          = 0;
			hr = m_pDeviceD3D10->CreateTexture2D(&td, 0, &m_pTexture[DISPLAY_NAME]);
			if ( SUCCEEDED(hr) ) {
				D3D10_SHADER_RESOURCE_VIEW_DESC srd;
				srd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
				srd.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
				srd.Texture2D.MostDetailedMip = 0;
				srd.Texture2D.MipLevels = 1;
				hr = m_pDeviceD3D10->CreateShaderResourceView(m_pTexture[DISPLAY_NAME], &srd, &m_pShaderResView[DISPLAY_NAME]);
				if ( SUCCEEDED(hr) ) {
					D3D10_TEXTURE2D_DESC desc;
					m_pTexture[DISPLAY_NAME]->GetDesc(&desc);
					D3D10_MAPPED_TEXTURE2D mappedTex;
					hr = m_pTexture[DISPLAY_NAME]->Map(0, D3D10_MAP_WRITE_DISCARD, 0, &mappedTex);
					if ( SUCCEEDED(hr) ) {
						CopyRect(&m_DisplayName.rName, &rect);
						int i, j;
						unsigned int *pTexture = (unsigned int*)mappedTex.pData;
						unsigned int *pSrc = reinterpret_cast<unsigned int*>(text_data.get()) + m_DisplayName.width * (m_DisplayName.height - 1);
						int blend = 2;
						for (i = 0; i < m_DisplayName.height; i++) {
							for (j = 0; j < m_DisplayName.width; j++) {
								if (blend == 0) {
									if (pSrc[j] == D3D_INV_BCKGR_COLOR) {
										pTexture[j] = pSrc[j] | 0x40000000;
									}
									else {
										pTexture[j] = pSrc[j] | 0xff000000;
									}
								}
								else if (blend == 1) {
									unsigned int grey = *(unsigned char*)&pSrc[j];
									if (pSrc[j] == D3D_INV_BCKGR_COLOR)
										pTexture[j] = D3D_INV_BCKGR_COLOR | 0x40000000;
									else
										pTexture[j] = D3D_TEXT_COLOR | (grey << 24);
								}
								else {
									unsigned int grey = *(unsigned char*)&pSrc[j];
									if (pSrc[j] == D3D_INV_BCKGR_COLOR)
										pTexture[j] = D3D_INV_BCKGR_COLOR | 0x40000000;
									else
										pTexture[j] = pSrc[j] | (grey << 24);
								}
							}
							pTexture += mappedTex.RowPitch / 4;
							pSrc -= m_DisplayName.width;
						}
						m_pTexture[DISPLAY_NAME]->Unmap(0);
					}
				}
			}

			DeleteObject(hbr);
			DeleteObject(hFont);
		}

		DeleteObject(bmap);
		DeleteDC(myDc);
		ReleaseDC(NULL, hDC);

		m_DisplayName.update = false;
	}

	return 0;
}