#include "CfgHelper.h"
#include "../std/cpplib/VS_RegistryKey.h"
#include "../std/cpplib/VS_RegistryConst.h"
#include "../std/cpplib/VS_WideStr.h"
#include "std/VS_RegistryPasswordEncryption.h"

namespace tc
{
#define GET_STRING(name) if (cfg.GetValue(tmp_char_buff, sizeof(tmp_char_buff), VS_REG_STRING_VT, name)) params[name] = tmp_char_buff;
#define GET_LONG(name) if (cfg.GetValue(&temp, sizeof(temp), VS_REG_INTEGER_VT, name) != 0) params[name] = std::to_string(temp);

// kt: not supported yet, when linux port
//// 2 - "\0\0"
//#define GET_WMULTYSTRING(name) wchar_t *p; int size = 0;\
//	if ((size = cfg.GetValue(p, VS_REG_WSTRING_VT,name)) && size > 2){\
//		std::string res;\
//		res.resize(size);\
//		memcpy((void *)res.c_str(), p, size);\
//		params[name] = res;\
//		::free(p);\
//	}

bool ReadCfg(VS_RegistryKey& cfg, tc::cfg_params_t& params)
{
	if (!cfg.IsValid())
		return false;

	int32_t temp;
	char tmp_char_buff[2048];

	GET_LONG(LDAP_SERVER_TYPE_TAG);
	GET_STRING(LDAP_DOMAIN_TAG);
	GET_STRING(LDAP_BASEDN_TAG);
	GET_STRING(LDAP_SERVER_TAG);
	GET_STRING(LDAP_OUR_DOMAIN_TAG);
	GET_LONG(LDAP_PORT_TAG);
	GET_LONG(LDAP_SECURE_TAG);
	GET_LONG(LDAP_AUTOVERIFY_SERVERCERT_TAG);
	GET_LONG(LDAP_VERSION_TAG);
	GET_LONG(LDAP_AUTO_DETECT_TAG);
	GET_LONG(LDAP_AUTH_METHOD_TAG);
	GET_STRING(LDAP_AUTH_USER_TAG);
	GET_STRING(LDAP_AUTH_DOMAIN_TAG);
	GET_STRING(LDAP_AUTH_PASSWORD_TAG_NEW);
	auto it = params.find(LDAP_AUTH_PASSWORD_TAG_NEW);
	if (it != std::end(params))
		it->second = sec::DecryptRegistryPassword(params[LDAP_AUTH_USER_TAG], it->second);
	else
		GET_STRING(LDAP_AUTH_PASSWORD_TAG_OLD);
	GET_LONG(LDAP_REFERRAL_TAG);
	GET_LONG(LDAP_REFERRAL_HOPS_TAG);
	GET_LONG(LDAP_TIMEOUT_TAG);
	GET_LONG(LDAP_AB_REFRESH_TAG);
	GET_LONG("Manage Address Book");
	GET_LONG(LDAP_MAX_RESULTS);
	GET_STRING(LDAP_AVATARS_PATH_TAG);
	GET_LONG(LDAP_USE_AVATARS_TAG);
	GET_LONG(LDAP_ALLOW_AVATAR_PROPAGATING_TAG);
	GET_LONG(LDAP_AVATARS_SIZE_TAG);
	GET_LONG(LDAP_AVATARS_QUALITY_TAG);

	// attrs
	GET_STRING(LDAP_ATTR_LOGIN_TAG);
	GET_STRING(LDAP_ATTR_DISPLAYNAME_TAG);
	GET_STRING(LDAP_ATTR_PHONE_MOBILE_TAG);
	GET_STRING(LDAP_ATTR_PHONE_WORK_TAG);
	GET_STRING(LDAP_ATTR_PHONE_HOME_TAG);
	GET_STRING(LDAP_ATTR_USER_STATUS_TAG);
	GET_STRING(LDAP_ATTR_USER_ID_TAG);
	GET_STRING(LDAP_ATTR_FULL_ID_TAG);
	GET_STRING(LDAP_ATTR_EMAIL_TAG);
	GET_STRING(LDAP_ATTR_FIRSTNAME_TAG);
	GET_STRING(LDAP_ATTR_MIDDLENAME_TAG);
	GET_STRING(LDAP_ATTR_LASTNAME_TAG);
	GET_STRING(LDAP_ATTR_COMPANY_TAG);
	GET_STRING(LDAP_ATTR_GROUP_MEMBER_TAG);
	GET_STRING(LDAP_ATTR_MEMBEROF_TAG);
	GET_STRING(LDAP_ATTR_DETAILED_USER_INFO_TAG);
	GET_STRING(LDAP_ATTR_PRIMARY_GROUP_ID_TAG);
	GET_STRING(LDAP_ATTR_PRIMARY_GROUP_TOKEN_TAG);
	GET_STRING(LDAP_ATTR_OBJECT_SID_TAG);
	GET_STRING(LDAP_ATTR_AVATARS_TAG);
	GET_STRING(STORAGE_TYPE_KEY_NAME);
	GET_STRING(LDAP_ATTR_USER_ALIAS_LIST_TAG);

	GET_LONG(LDAP_ENABLE_TRUST_TAG);
	GET_STRING(LDAP_ATTR_TRUST_PARTNER_TAG);
	GET_STRING(LDAP_ATTR_FLAT_NAME_TAG);
	GET_STRING(LDAP_FILTER_TRUSTED_DOMAIN_TAG);
	GET_STRING(LDAP_FILTER_FOREIGN_SECURITY_PRINCIPAL_TAG);

	// filters
	GET_STRING(LDAP_FILTER_LOGIN_TAG);
	GET_STRING(LDAP_FILTER_CALLID_TAG);
	GET_STRING(LDAP_FILTER_AB_TAG);
	GET_STRING(LDAP_FILTER_DISABLED_TAG);
	GET_STRING(LDAP_FILTER_GROUP_TAG);
	GET_STRING(LDAP_GROUP_TAG);
	GET_LONG(LDAP_FILTER_SEARCH_BY_LOGIN_GROUP_TAG);

	// kt: not supported yet, when linux port
	//GET_WMULTYSTRING(LDAP_REFERRAL_SKIP_TAG);

	//#ifdef _SVKS_M_BUILD_
	//	VS_WideStr tmp2;
	//	cfg.GetValue(tmp2.m_str, VS_REG_WSTRING_VT, LDAP_REGION_TAG);
	//	m_region.set(tmp2);
	//#endif

	GET_LONG(LDAP_AUTOMANAGEAB_MAXUSERS_TAG);

	GET_LONG(ALLOWED_BY_SERVER_MAX_BW);
	GET_LONG(ALLOWED_BY_SERVER_MAX_FPS);
	GET_LONG(ALLOWED_BY_SERVER_MAX_WXH);

	GET_STRING(LDAP_ATTR_ADDRESS_BOOK_TAG);
	GET_STRING(LDAP_ATTR_SERVER_NAME_TAG);

	GET_LONG(NTLM_ON_TAG);
	GET_LONG(LDAP_SORT_CONTROL_SCHEME_TAG);

	return true;
}

bool ReadCfg(tc::cfg_params_t& params)
{
	VS_RegistryKey cfg(false, CONFIGURATION_KEY);
	return ReadCfg(cfg, params);
}

#undef GET_STRING
#undef GET_LONG

}  // namespace tc
