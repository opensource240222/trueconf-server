# Спецификация для `vs::Watchdog`
Класс `vs::Watchdog` предоставляет
1. возможность регистрировать экземпляры `VS_Testable` и контролировать, какой из компонентов не прошел тест;
2. метод `Shutdown()`, при вызове которого компоненты сервера (сервисы, SR, TR, ACS, asio) удаляются и процесс сервера завершается (без ошибок);
3. метод `Restart()`, при вызове которого компоненты сервера (сервисы, SR, TR, ACS, asio) удаляются и процесс перезапускается (с такими же параметрами командной строки);
4. обработку сигналов `SIGINT` и `SIGTERM` при получении которых сервер выключается (как при вызове `Shutdown()`).

   TODO: Надо убрать обработку сигналов `SIGABRT`, `SIGFPE`, `SIGILL` и `SIGSEGV`.

При создании `vs::Watchdog` ему передаются:
1. функтор, вызов которого инициирует выключение сервера;
2. оригинальные аргументы процесса (`argv` из `main`);

## Процедура `Shutdown`
* Меняется внутренний статус с `running` на `shutdown`;
* Вызывается функтор указанный при инициализации.

## Процедура `Restart`
Для Windows сейчас мы таскаем за собой отдельную программу `tc_rstr.exe`, которая перезапускает службу сервера.
Программа запускается при вызове метода `Restart`.
Возможно, можно перезапускать службу прямо из процесса сервера.
Если да, то тогда надо избавиться от рестартера, если нет, то поправить ошибки в нем (рестартер не может рестартануть сервер, если для службы указан параметр Instance).

### Возможное решение
* `Restart()` меняется внутренний статус с `running` на `restart` и вызывает функтор указанный при инициализации;
* Код использующий `vs::Watchdog` вызывает метод `OnExit()` перед выходом из `main`;
* `OnExit()` проверяет что внутренний статус равен `restart` и перезапускает текущий процесс, для этого:
  - на Linux вызывает `execv("/proc/self/exe", argv);`.
    В результате процесс перезапускается с сохранением pid, что важно для системы контроля за сервисами, так как они идентифицируются по pid;
  - на Windows запускает новый процесс для текущего исполняемого файла с аргументами полученными через `GetCommandLineW` (`argv` полученный при инициализации не используется) и опцией `--WaitForPID`, аргументом которой является pid текущего процесса;
* Если новый запущенный процесс встречает опцию `--WaitForPID`, то он вызывает статический метод `WaitForPID()` с аргументом этой опции;
* `WaitForPID()` на Linux не делает ничего, а на Windows ждёт завершения процесса с указанным ID.
  Если указанный процесс не завершается за фиксированное время, то она пробует его завершить с помощью `TerminateProcess`.
